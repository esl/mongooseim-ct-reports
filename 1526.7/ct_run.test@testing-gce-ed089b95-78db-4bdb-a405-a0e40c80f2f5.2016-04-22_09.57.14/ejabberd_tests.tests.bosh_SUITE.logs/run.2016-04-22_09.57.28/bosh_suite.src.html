<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/test/ejabberd_tests/tests/bosh_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%==============================================================================</i>
<a name="2"/>    2: <i>%% Copyright 2012 Erlang Solutions Ltd.</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="5"/>    5: <i>%% you may not use this file except in compliance with the License.</i>
<a name="6"/>    6: <i>%% You may obtain a copy of the License at</i>
<a name="7"/>    7: <i>%%</i>
<a name="8"/>    8: <i>%% http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="11"/>   11: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="12"/>   12: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="13"/>   13: <i>%% See the License for the specific language governing permissions and</i>
<a name="14"/>   14: <i>%% limitations under the License.</i>
<a name="15"/>   15: <i>%%==============================================================================</i>
<a name="16"/>   16: 
<a name="17"/>   17: <b>-module</b>(bosh_SUITE).
<a name="18"/>   18: <b>-compile</b>(export_all).
<a name="19"/>   19: 
<a name="20"/>   20: <b>-include_lib</b>(&quot;escalus/include/escalus.hrl&quot;).
<a name="21"/>   21: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="22"/>   22: <b>-include_lib</b>(&quot;exml/include/exml.hrl&quot;).
<a name="23"/>   23: 
<a name="24"/>   24: <i>%%--------------------------------------------------------------------</i>
<a name="25"/>   25: <i>%% Suite configuration</i>
<a name="26"/>   26: <i>%%--------------------------------------------------------------------</i>
<a name="27"/>   27: 
<a name="28"/>   28: <b>-define</b>(INACTIVITY, 2). %% seconds
<a name="29"/>   29: <b>-define</b>(MAX_WAIT, 5). %% seconds
<a name="30"/>   30: <b>-define</b>(INVALID_RID_OFFSET, 999).
<a name="31"/>   31: 
<a name="all-0"/><a name="32"/>   32: <b>all</b>() -&gt;
<a name="33"/>   33:     [{group, essential},
<a name="34"/>   34: 
<a name="35"/>   35:      {group, chat},
<a name="36"/>   36: 
<a name="37"/>   37:      {group, time},
<a name="38"/>   38:      {group, acks},
<a name="39"/>   39: 
<a name="40"/>   40:      {group, essential_https},
<a name="41"/>   41:      {group, chat_https}
<a name="42"/>   42:      ].
<a name="43"/>   43: 
<a name="groups-0"/><a name="44"/>   44: <b>groups</b>() -&gt;
<a name="45"/>   45:     [{essential, [shuffle], essential_test_cases()},
<a name="46"/>   46:      {essential_https, [shuffle], essential_test_cases()},
<a name="47"/>   47:      {chat, [shuffle], chat_test_cases()},
<a name="48"/>   48:      {chat_https, [shuffle], chat_test_cases()},
<a name="49"/>   49:      {time, [parallel], time_test_cases()},
<a name="50"/>   50:      {acks, [shuffle], acks_test_cases()}].
<a name="51"/>   51: 
<a name="suite-0"/><a name="52"/>   52: <b>suite</b>() -&gt;
<a name="53"/>   53:     escalus:suite().
<a name="54"/>   54: 
<a name="essential_test_cases-0"/><a name="55"/>   55: <b>essential_test_cases</b>() -&gt;
<a name="56"/>   56:     [create_and_terminate_session,
<a name="57"/>   57:      accept_higher_hold_value,
<a name="58"/>   58:      do_not_accept_0_hold_value,
<a name="59"/>   59:      options_request,
<a name="60"/>   60:      get_request,
<a name="61"/>   61:      post_empty_body,
<a name="62"/>   62:      put_request].
<a name="63"/>   63: 
<a name="chat_test_cases-0"/><a name="64"/>   64: <b>chat_test_cases</b>() -&gt;
<a name="65"/>   65:     [interleave_requests,
<a name="66"/>   66:      simple_chat,
<a name="67"/>   67:      cdata_escape_chat,
<a name="68"/>   68:      escape_attr_chat,
<a name="69"/>   69:      cant_send_invalid_rid,
<a name="70"/>   70:      multiple_stanzas,
<a name="71"/>   71:      namespace,
<a name="72"/>   72:      stream_error].
<a name="73"/>   73: 
<a name="time_test_cases-0"/><a name="74"/>   74: <b>time_test_cases</b>() -&gt;
<a name="75"/>   75:     [disconnect_inactive,
<a name="76"/>   76:      connection_interrupted,
<a name="77"/>   77:      interrupt_long_poll_is_activity,
<a name="78"/>   78:      reply_on_pause,
<a name="79"/>   79:      cant_pause_for_too_long,
<a name="80"/>   80:      pause_request_is_activity,
<a name="81"/>   81:      reply_in_time
<a name="82"/>   82:     ].
<a name="83"/>   83: 
<a name="acks_test_cases-0"/><a name="84"/>   84: <b>acks_test_cases</b>() -&gt;
<a name="85"/>   85:     [server_acks,
<a name="86"/>   86:      force_report,
<a name="87"/>   87:      force_retransmission,
<a name="88"/>   88:      force_cache_trimming].
<a name="89"/>   89: 
<a name="90"/>   90: <i>%%--------------------------------------------------------------------</i>
<a name="91"/>   91: <i>%% Init &amp; teardown</i>
<a name="92"/>   92: <i>%%--------------------------------------------------------------------</i>
<a name="93"/>   93: 
<a name="init_per_suite-1"/><a name="94"/>   94: <b>init_per_suite</b>(Config) -&gt;
<a name="95"/>   95:     escalus:init_per_suite([{escalus_user_db, {module, escalus_ejabberd}} | Config]).
<a name="96"/>   96: 
<a name="end_per_suite-1"/><a name="97"/>   97: <b>end_per_suite</b>(Config) -&gt;
<a name="98"/>   98:     escalus_fresh:clean(),
<a name="99"/>   99:     escalus:end_per_suite(Config).
<a name="100"/>  100: 
<a name="init_per_group-2"/><a name="101"/>  101: <b>init_per_group</b>(time, Config) -&gt;
<a name="102"/>  102:     NewConfig = escalus_ejabberd:setup_option(max_wait(), Config),
<a name="103"/>  103:     escalus_ejabberd:setup_option(inactivity(), NewConfig);
<a name="104"/>  104: <b>init_per_group</b>(essential, Config) -&gt;
<a name="105"/>  105:     [{user, carol} | Config];
<a name="106"/>  106: <b>init_per_group</b>(essential_https, Config) -&gt;
<a name="107"/>  107:     [{user, carol_s} | Config];
<a name="108"/>  108: <b>init_per_group</b>(chat_https, Config) -&gt;
<a name="109"/>  109:     Config1 = escalus:create_users(Config, escalus:get_users([carol, carol_s, geralt, alice])),
<a name="110"/>  110:     [{user, carol_s} | Config1];
<a name="111"/>  111: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="112"/>  112:     Config1 = escalus:create_users(Config, escalus:get_users([carol, carol_s, geralt, alice])),
<a name="113"/>  113:     [{user, carol} | Config1].
<a name="114"/>  114: 
<a name="end_per_group-2"/><a name="115"/>  115: <b>end_per_group</b>(time, Config) -&gt;
<a name="116"/>  116:     NewConfig = escalus_ejabberd:reset_option(max_wait(), Config),
<a name="117"/>  117:     escalus_ejabberd:reset_option(inactivity(), NewConfig);
<a name="118"/>  118: <b>end_per_group</b>(GroupName, Config)
<a name="119"/>  119:     when GroupName =:= essential; GroupName =:= essential_https -&gt;
<a name="120"/>  120:     Config;
<a name="121"/>  121: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="122"/>  122:     R = escalus:delete_users(Config, escalus:get_users([carol, carol_s, geralt, alice])),
<a name="123"/>  123:     mongoose_helper:clear_last_activity(Config, carol),
<a name="124"/>  124:     Config,
<a name="125"/>  125:     R.
<a name="126"/>  126: 
<a name="init_per_testcase-2"/><a name="127"/>  127: <b>init_per_testcase</b>(server_acks = CaseName, Config) -&gt;
<a name="128"/>  128:     NewConfig = escalus_ejabberd:setup_option(server_acks_opt(), Config),
<a name="129"/>  129:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="130"/>  130: <b>init_per_testcase</b>(CaseName, Config) -&gt;
<a name="131"/>  131:     escalus:init_per_testcase(CaseName, Config).
<a name="132"/>  132: 
<a name="end_per_testcase-2"/><a name="133"/>  133: <b>end_per_testcase</b>(server_acks = CaseName, Config) -&gt;
<a name="134"/>  134:     NewConfig = escalus_ejabberd:reset_option(server_acks_opt(), Config),
<a name="135"/>  135:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="136"/>  136: <b>end_per_testcase</b>(CaseName, Config) -&gt;
<a name="137"/>  137:     escalus:end_per_testcase(CaseName, Config).
<a name="138"/>  138: 
<a name="139"/>  139: <i>%%--------------------------------------------------------------------</i>
<a name="140"/>  140: <i>%% Tests</i>
<a name="141"/>  141: <i>%%--------------------------------------------------------------------</i>
<a name="142"/>  142: 
<a name="create_and_terminate_session-1"/><a name="143"/>  143: <b>create_and_terminate_session</b>(Config) -&gt;
<a name="144"/>  144:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="145"/>  145:     CarolSpec = proplists:get_value(?config(user, Config), NamedSpecs),
<a name="146"/>  146:     {ok, Conn} = escalus_bosh:connect(CarolSpec),
<a name="147"/>  147: 
<a name="148"/>  148:     %% Assert there are no BOSH sessions on the server.
<a name="149"/>  149:     0 = length(get_bosh_sessions()),
<a name="150"/>  150: 
<a name="151"/>  151:     Domain = escalus_config:get_config(ejabberd_domain, Config),
<a name="152"/>  152:     Body = escalus_bosh:session_creation_body(get_bosh_rid(Conn), Domain),
<a name="153"/>  153:     ok = escalus_bosh:send_raw(Conn, Body),
<a name="154"/>  154:     escalus_connection:get_stanza(Conn, session_creation_response),
<a name="155"/>  155: 
<a name="156"/>  156:     %% Assert that a BOSH session was created.
<a name="157"/>  157:     1 = length(get_bosh_sessions()),
<a name="158"/>  158: 
<a name="159"/>  159:     Sid = get_bosh_sid(Conn),
<a name="160"/>  160:     Terminate = escalus_bosh:session_termination_body(get_bosh_rid(Conn), Sid),
<a name="161"/>  161:     ok = escalus_bosh:send_raw(Conn, Terminate),
<a name="162"/>  162: 
<a name="163"/>  163:     timer:sleep(100),
<a name="164"/>  164:     %% Assert the session was terminated.
<a name="165"/>  165:     0 = length(get_bosh_sessions()).
<a name="166"/>  166: 
<a name="accept_higher_hold_value-1"/><a name="167"/>  167: <b>accept_higher_hold_value</b>(Config) -&gt;
<a name="168"/>  168:     #xmlel{attrs = RespAttrs} = send_specific_hold(Config, &lt;&lt;&quot;2&quot;&gt;&gt;),
<a name="169"/>  169:     {&lt;&lt;&quot;hold&quot;&gt;&gt;, &lt;&lt;&quot;1&quot;&gt;&gt;} = lists:keyfind(&lt;&lt;&quot;hold&quot;&gt;&gt;, 1, RespAttrs).
<a name="170"/>  170: 
<a name="do_not_accept_0_hold_value-1"/><a name="171"/>  171: <b>do_not_accept_0_hold_value</b>(Config) -&gt;
<a name="172"/>  172:     #xmlel{attrs = RespAttrs} = send_specific_hold(Config, &lt;&lt;&quot;0&quot;&gt;&gt;),
<a name="173"/>  173:     {&lt;&lt;&quot;type&quot;&gt;&gt;, &lt;&lt;&quot;terminate&quot;&gt;&gt;} = lists:keyfind(&lt;&lt;&quot;type&quot;&gt;&gt;, 1, RespAttrs).
<a name="174"/>  174: 
<a name="175"/>  175: 
<a name="send_specific_hold-2"/><a name="176"/>  176: <b>send_specific_hold</b>(Config, HoldValue) -&gt;
<a name="177"/>  177:     {Server, Path, Client} = get_fusco_connection(Config),
<a name="178"/>  178: 
<a name="179"/>  179:     Rid = random:uniform(1000000),
<a name="180"/>  180:     Body0 = escalus_bosh:session_creation_body(2, &lt;&lt;&quot;1.0&quot;&gt;&gt;, &lt;&lt;&quot;en&quot;&gt;&gt;, Rid, Server, nil),
<a name="181"/>  181:     #xmlel{attrs = Attrs0} = Body0,
<a name="182"/>  182:     Attrs = lists:keyreplace(&lt;&lt;&quot;hold&quot;&gt;&gt;, 1, Attrs0, {&lt;&lt;&quot;hold&quot;&gt;&gt;, HoldValue}),
<a name="183"/>  183:     Body = Body0#xmlel{attrs = Attrs},
<a name="184"/>  184: 
<a name="185"/>  185:     Result = fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, exml:to_iolist(Body)),
<a name="186"/>  186:     {{&lt;&lt;&quot;200&quot;&gt;&gt;,&lt;&lt;&quot;OK&quot;&gt;&gt;}, _Headers, RespBody, _, _} = Result,
<a name="187"/>  187: 
<a name="188"/>  188:     {ok, #xmlel{attrs = RespAttrs} = Resp} = exml:parse(RespBody),
<a name="189"/>  189:     case lists:keyfind(&lt;&lt;&quot;sid&quot;&gt;&gt;, 1, RespAttrs) of
<a name="190"/>  190:         {&lt;&lt;&quot;sid&quot;&gt;&gt;, SID} -&gt;
<a name="191"/>  191:             TerminateBody = escalus_bosh:session_termination_body(Rid + 1, SID),
<a name="192"/>  192:             fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, exml:to_iolist(TerminateBody));
<a name="193"/>  193:         _ -&gt;
<a name="194"/>  194:             skip
<a name="195"/>  195:     end,
<a name="196"/>  196:     fusco_cp:stop(Client),
<a name="197"/>  197:     Resp.
<a name="198"/>  198: 
<a name="fusco_request-4"/><a name="199"/>  199: <b>fusco_request</b>(Client, Method, Path, Body) -&gt;
<a name="200"/>  200:     fusco_request(Client, Method, Path, Body, []).
<a name="201"/>  201: 
<a name="fusco_request-5"/><a name="202"/>  202: <b>fusco_request</b>(Client, Method, Path, Body, HeadersIn) -&gt;
<a name="203"/>  203:     Headers = [{&lt;&lt;&quot;Content-Type&quot;&gt;&gt;, &lt;&lt;&quot;text/xml; charset=utf-8&quot;&gt;&gt;} | HeadersIn],
<a name="204"/>  204:     {ok, Result} = fusco_cp:request(Client, Path, Method, Headers, Body, 2, 5000),
<a name="205"/>  205:     Result.
<a name="206"/>  206: 
<a name="207"/>  207: 
<a name="options_request-1"/><a name="208"/>  208: <b>options_request</b>(Config) -&gt;
<a name="209"/>  209:     {Server, Path, Client} = get_fusco_connection(Config),
<a name="210"/>  210:     Result = fusco_request(Client, &lt;&lt;&quot;OPTIONS&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;, [{&lt;&lt;&quot;Origin&quot;&gt;&gt;, Server}]),
<a name="211"/>  211:     fusco_cp:stop(Client),
<a name="212"/>  212:     {{&lt;&lt;&quot;200&quot;&gt;&gt;, &lt;&lt;&quot;OK&quot;&gt;&gt;}, Headers, &lt;&lt;&gt;&gt;, _, _} = Result,
<a name="213"/>  213:     &lt;&lt;&quot;1728000&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-max-age&quot;&gt;&gt;, Headers),
<a name="214"/>  214:     &lt;&lt;&quot;Content-Type&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-allow-headers&quot;&gt;&gt;, Headers),
<a name="215"/>  215:     &lt;&lt;&quot;POST, OPTIONS, GET&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-allow-methods&quot;&gt;&gt;, Headers),
<a name="216"/>  216:     Server = proplists:get_value(&lt;&lt;&quot;access-control-allow-origin&quot;&gt;&gt;, Headers).
<a name="217"/>  217: 
<a name="get_request-1"/><a name="218"/>  218: <b>get_request</b>(Config) -&gt;
<a name="219"/>  219:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="220"/>  220:     Result = fusco_request(Client, &lt;&lt;&quot;GET&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;),
<a name="221"/>  221:     fusco_cp:stop(Client),
<a name="222"/>  222:     {{&lt;&lt;&quot;200&quot;&gt;&gt;,&lt;&lt;&quot;OK&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="223"/>  223: 
<a name="put_request-1"/><a name="224"/>  224: <b>put_request</b>(Config) -&gt;
<a name="225"/>  225:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="226"/>  226:     Result = fusco_request(Client, &lt;&lt;&quot;PUT&quot;&gt;&gt;, Path, &lt;&lt;&quot;not allowed body&quot;&gt;&gt;),
<a name="227"/>  227:     fusco_cp:stop(Client),
<a name="228"/>  228:     {{&lt;&lt;&quot;405&quot;&gt;&gt;,&lt;&lt;&quot;Method Not Allowed&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="229"/>  229: 
<a name="post_empty_body-1"/><a name="230"/>  230: <b>post_empty_body</b>(Config) -&gt;
<a name="231"/>  231:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="232"/>  232:     Result = fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;),
<a name="233"/>  233:     fusco_cp:stop(Client),
<a name="234"/>  234:     {{&lt;&lt;&quot;400&quot;&gt;&gt;,&lt;&lt;&quot;Bad Request&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="235"/>  235: 
<a name="get_fusco_connection-1"/><a name="236"/>  236: <b>get_fusco_connection</b>(Config) -&gt;
<a name="237"/>  237:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="238"/>  238:     CarolSpec = proplists:get_value(?config(user, Config), NamedSpecs),
<a name="239"/>  239:     Server = proplists:get_value(server, CarolSpec),
<a name="240"/>  240:     Path = proplists:get_value(path, CarolSpec),
<a name="241"/>  241:     Port = proplists:get_value(port, CarolSpec),
<a name="242"/>  242:     UseSSL = proplists:get_value(ssl, CarolSpec, false),
<a name="243"/>  243:     {ok, Client} = fusco_cp:start_link({binary_to_list(Server), Port, UseSSL}, [], 1),
<a name="244"/>  244:     {Server, Path, Client}.
<a name="245"/>  245: 
<a name="stream_error-1"/><a name="246"/>  246: <b>stream_error</b>(Config) -&gt;
<a name="247"/>  247:     escalus:story(
<a name="248"/>  248:       Config, [{?config(user, Config), 1}],
<a name="249"/>  249:       fun(Carol) -&gt;
<a name="250"/>  250:               %% Send a stanza with invalid 'from'
<a name="251"/>  251:               %% attribute to trigger a stream error from
<a name="252"/>  252:               %% the server.
<a name="253"/>  253:               BadMessage = escalus_stanza:chat(
<a name="254"/>  254:                              &lt;&lt;&quot;not_carol@localhost&quot;&gt;&gt;,
<a name="255"/>  255:                              &lt;&lt;&quot;geralt@localhost&quot;&gt;&gt;,
<a name="256"/>  256:                              &lt;&lt;&quot;I am not Carol&quot;&gt;&gt;),
<a name="257"/>  257:               escalus_client:send(Carol, BadMessage),
<a name="258"/>  258:               escalus:assert(is_stream_error, [&lt;&lt;&quot;invalid-from&quot;&gt;&gt;, &lt;&lt;&gt;&gt;],
<a name="259"/>  259:                              escalus_client:wait_for_stanza(Carol)),
<a name="260"/>  260:               %% connection should be closed, let's wait
<a name="261"/>  261:               true = wait_for_close(Carol, 10)
<a name="262"/>  262:       end).
<a name="263"/>  263: 
<a name="interleave_requests-1"/><a name="264"/>  264: <b>interleave_requests</b>(Config) -&gt;
<a name="265"/>  265:     escalus:story(Config, [{geralt, 1}], fun(Geralt) -&gt;
<a name="266"/>  266: 
<a name="267"/>  267:         Carol = start_client(Config, ?config(user, Config), &lt;&lt;&quot;bosh&quot;&gt;&gt;),
<a name="268"/>  268:         Rid = get_bosh_rid(Carol),
<a name="269"/>  269:         Sid = get_bosh_sid(Carol),
<a name="270"/>  270: 
<a name="271"/>  271:         Empty2 = escalus_bosh:empty_body(Rid + 1, Sid),
<a name="272"/>  272:         Chat2 = Empty2#xmlel{
<a name="273"/>  273:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd!&quot;&gt;&gt;)]},
<a name="274"/>  274:         escalus_bosh:send_raw(Carol, Chat2),
<a name="275"/>  275: 
<a name="276"/>  276:         Empty1 = escalus_bosh:empty_body(Rid, Sid),
<a name="277"/>  277:         Chat1 = Empty1#xmlel{
<a name="278"/>  278:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st!&quot;&gt;&gt;)]},
<a name="279"/>  279:         escalus_bosh:send_raw(Carol, Chat1),
<a name="280"/>  280: 
<a name="281"/>  281:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st!&quot;&gt;&gt;],
<a name="282"/>  282:                        escalus_client:wait_for_stanza(Geralt)),
<a name="283"/>  283:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd!&quot;&gt;&gt;],
<a name="284"/>  284:                        escalus_client:wait_for_stanza(Geralt))
<a name="285"/>  285: 
<a name="286"/>  286:     end).
<a name="287"/>  287: 
<a name="288"/>  288: 
<a name="simple_chat-1"/><a name="289"/>  289: <b>simple_chat</b>(Config) -&gt;
<a name="290"/>  290:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="291"/>  291: 
<a name="292"/>  292:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hi!&quot;&gt;&gt;)),
<a name="293"/>  293:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hi!&quot;&gt;&gt;],
<a name="294"/>  294:                        escalus_client:wait_for_stanza(Geralt)),
<a name="295"/>  295: 
<a name="296"/>  296:         escalus_client:send(Geralt,
<a name="297"/>  297:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="298"/>  298:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="299"/>  299:                        escalus_client:wait_for_stanza(Carol))
<a name="300"/>  300: 
<a name="301"/>  301:         end).
<a name="302"/>  302: 
<a name="cdata_escape_chat-1"/><a name="303"/>  303: <b>cdata_escape_chat</b>(Config) -&gt;
<a name="304"/>  304:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="305"/>  305:         special_chars_helper:check_cdata_from_to(Carol, Carol, &lt;&lt;&quot;Hi! &amp; &lt; &gt; &quot;&gt;&gt;),
<a name="306"/>  306:         special_chars_helper:check_cdata_from_to(Geralt, Carol, &lt;&lt;&quot;Hi there! &amp; &lt; &gt; &quot;&gt;&gt;)
<a name="307"/>  307: 
<a name="308"/>  308:     end).
<a name="309"/>  309: 
<a name="escape_attr_chat-1"/><a name="310"/>  310: <b>escape_attr_chat</b>(Config) -&gt;
<a name="311"/>  311:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="312"/>  312:         special_chars_helper:check_attr_from_to(Carol, Geralt),
<a name="313"/>  313:         special_chars_helper:check_attr_from_to(Geralt, Carol)
<a name="314"/>  314:     end).
<a name="315"/>  315: 
<a name="cant_send_invalid_rid-1"/><a name="316"/>  316: <b>cant_send_invalid_rid</b>(Config) -&gt;
<a name="317"/>  317:     escalus:story(Config, [{?config(user, Config), 1}], fun(Carol) -&gt;
<a name="318"/>  318:         %% ct:pal(&quot;This test will leave invalid rid, session not found&quot;
<a name="319"/>  319:         %%        &quot; errors in the server log~n&quot;),
<a name="320"/>  320: 
<a name="321"/>  321:         %% NOTICE 1
<a name="322"/>  322:         %% This test will provoke the server to log the following message:
<a name="323"/>  323:         %%
<a name="324"/>  324:         %% mod_bosh_socket:handle_stream_event:401
<a name="325"/>  325:         %% invalid rid XXX, expected YYY, difference ?INVALID_RID_OFFSET:
<a name="326"/>  326: 
<a name="327"/>  327:         %% NOTICE 2
<a name="328"/>  328:         %% Escalus will try to close the session under test when the story
<a name="329"/>  329:         %% completes. This will leave the following message in the log:
<a name="330"/>  330:         %%
<a name="331"/>  331:         %% mod_bosh:forward_body:265 session not found!
<a name="332"/>  332: 
<a name="333"/>  333:         InvalidRid = get_bosh_rid(Carol) + ?INVALID_RID_OFFSET,
<a name="334"/>  334:         Sid = get_bosh_sid(Carol),
<a name="335"/>  335:         Empty = escalus_bosh:empty_body(InvalidRid, Sid),
<a name="336"/>  336:         escalus_bosh:send_raw(Carol, Empty),
<a name="337"/>  337: 
<a name="338"/>  338:         escalus:assert(is_stream_end, escalus:wait_for_stanza(Carol)),
<a name="339"/>  339:         true = wait_for_close(Carol, 10),
<a name="340"/>  340:         true = wait_for_session_close(Sid, 10)
<a name="341"/>  341:         end).
<a name="342"/>  342: 
<a name="multiple_stanzas-1"/><a name="343"/>  343: <b>multiple_stanzas</b>(Config) -&gt;
<a name="344"/>  344:     escalus:story(Config, [{?config(user, Config), 1},{geralt, 1},{alice, 1}],
<a name="345"/>  345:                   fun(Carol, Geralt, Alice) -&gt;
<a name="346"/>  346:                 %% send a multiple stanza
<a name="347"/>  347:                 Server = escalus_client:server(Carol),
<a name="348"/>  348:                 Stanza1 = escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="349"/>  349:                 Stanza2 = escalus_stanza:chat_to(Alice, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="350"/>  350:                 Stanza3 = escalus_stanza:service_discovery(Server),
<a name="351"/>  351: 
<a name="352"/>  352:                 RID = escalus_bosh:get_rid(Carol),
<a name="353"/>  353:                 SID = escalus_bosh:get_sid(Carol),
<a name="354"/>  354:                 Body = escalus_bosh:empty_body(RID, SID),
<a name="355"/>  355:                 Stanza = Body#xmlel{children=[Stanza1,Stanza2,Stanza1,Stanza3]},
<a name="356"/>  356:                 escalus_bosh:send_raw(Carol, Stanza),
<a name="357"/>  357: 
<a name="358"/>  358:                 %% check whether each of stanzas has been processed correctly
<a name="359"/>  359:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="360"/>  360:                                escalus_client:wait_for_stanza(Geralt)),
<a name="361"/>  361:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="362"/>  362:                                escalus_client:wait_for_stanza(Alice)),
<a name="363"/>  363:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="364"/>  364:                                escalus_client:wait_for_stanza(Geralt)),
<a name="365"/>  365:                 escalus:assert(is_iq_result, escalus:wait_for_stanza(Carol))
<a name="366"/>  366:         end).
<a name="367"/>  367: 
<a name="namespace-1"/><a name="368"/>  368: <b>namespace</b>(Config) -&gt;
<a name="369"/>  369:     escalus:story(Config, [{?config(user, Config), 1},{geralt, 1}],
<a name="370"/>  370:         fun(Carol, Geralt) -&gt;
<a name="371"/>  371:             %% send a multiple stanza
<a name="372"/>  372:             Server = escalus_client:server(Carol),
<a name="373"/>  373: 
<a name="374"/>  374:             Stanza1 = escalus_stanza:service_discovery(Server),
<a name="375"/>  375:             Stanza2 = escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="376"/>  376:             Stanza3 = escalus_stanza:presence_direct(Carol, &lt;&lt;&quot;available&quot;&gt;&gt;),
<a name="377"/>  377: 
<a name="378"/>  378:             RID = escalus_bosh:get_rid(Carol),
<a name="379"/>  379:             SID = escalus_bosh:get_sid(Carol),
<a name="380"/>  380:             Body = escalus_bosh:empty_body(RID, SID),
<a name="381"/>  381:             Stanza = Body#xmlel{children=[Stanza1]},
<a name="382"/>  382:             escalus_bosh:send_raw(Carol, Stanza),
<a name="383"/>  383: 
<a name="384"/>  384:             IQResp = escalus:wait_for_stanza(Carol),
<a name="385"/>  385: 
<a name="386"/>  386:             escalus:assert(is_iq, [&lt;&lt;&quot;result&quot;&gt;&gt;], IQResp),
<a name="387"/>  387:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], IQResp),
<a name="388"/>  388: 
<a name="389"/>  389:             escalus_client:send(Geralt, Stanza2),
<a name="390"/>  390:             escalus_client:send(Geralt, Stanza3),
<a name="391"/>  391: 
<a name="392"/>  392:             Message = escalus:wait_for_stanza(Carol),
<a name="393"/>  393:             escalus:assert(is_chat_message, Message),
<a name="394"/>  394:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], Message),
<a name="395"/>  395: 
<a name="396"/>  396:             Presence  = escalus:wait_for_stanza(Carol),
<a name="397"/>  397:             escalus:assert(is_presence, Presence),
<a name="398"/>  398:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], Presence)
<a name="399"/>  399:         end).
<a name="400"/>  400: 
<a name="disconnect_inactive-1"/><a name="401"/>  401: <b>disconnect_inactive</b>(Config) -&gt;
<a name="402"/>  402:     escalus:fresh_story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="403"/>  403: 
<a name="404"/>  404:         Sid = get_bosh_sid(Carol),
<a name="405"/>  405:         {_, Sid, CarolSessionPid} = get_bosh_session(Sid),
<a name="406"/>  406:         %% Don't send new long-polling requests waiting for server push.
<a name="407"/>  407:         set_keepalive(Carol, false),
<a name="408"/>  408: 
<a name="409"/>  409:         %% Make Carol receive using the last remaining connection.
<a name="410"/>  410:         escalus_client:send(Geralt,
<a name="411"/>  411:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="412"/>  412: 
<a name="413"/>  413:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="414"/>  414:                        escalus_client:wait_for_stanza(Carol)),
<a name="415"/>  415: 
<a name="416"/>  416:         %% Ensure all connections for Carol have been closed.
<a name="417"/>  417:         [] = get_handlers(CarolSessionPid),
<a name="418"/>  418: 
<a name="419"/>  419:         %% Wait for disconnection because of inactivity timeout.
<a name="420"/>  420:         timer:sleep(2 * timer:seconds(?INACTIVITY)),
<a name="421"/>  421: 
<a name="422"/>  422:         %% Assert Carol has been disconnected due to inactivity.
<a name="423"/>  423:         false = is_sesssion_alive(Sid),
<a name="424"/>  424: 
<a name="425"/>  425:         %% We don't need to close the session in escalus_bosh:stop/1
<a name="426"/>  426:         mark_as_terminated(Carol)
<a name="427"/>  427: 
<a name="428"/>  428:         end).
<a name="429"/>  429: 
<a name="connection_interrupted-1"/><a name="430"/>  430: <b>connection_interrupted</b>(Config) -&gt;
<a name="431"/>  431:     escalus:fresh_story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="432"/>  432: 
<a name="433"/>  433:         %% Sanity check - there should be one BOSH session belonging
<a name="434"/>  434:         %% to Carol.
<a name="435"/>  435:         %% Turn off Escalus auto-reply, so that inactivity is triggered.
<a name="436"/>  436:         set_keepalive(Carol, false),
<a name="437"/>  437: 
<a name="438"/>  438:         Sid = get_bosh_sid(Carol),
<a name="439"/>  439: 
<a name="440"/>  440:         %% Terminate the connection, but don't notify the server.
<a name="441"/>  441:         escalus_connection:kill(Carol),
<a name="442"/>  442: 
<a name="443"/>  443:         %% Assert Carol has not been disconnected yet.
<a name="444"/>  444:         timer:sleep(100),
<a name="445"/>  445:         true = is_sesssion_alive(Sid),
<a name="446"/>  446: 
<a name="447"/>  447:         %% Wait for disconnection because of inactivity timeout.
<a name="448"/>  448:         %% Keep in mind this only works due to the max_wait also being lowered.
<a name="449"/>  449:         %% In other words, wait timeout must happen, so that there are
<a name="450"/>  450:         %% no requests held by the server for inactivity to cause disconnection.
<a name="451"/>  451:         timer:sleep(timer:seconds(?INACTIVITY) + timer:seconds(?MAX_WAIT)),
<a name="452"/>  452: 
<a name="453"/>  453:         %% Assert Carol has been disconnected due to inactivity.
<a name="454"/>  454:         false = is_sesssion_alive(Sid)
<a name="455"/>  455: 
<a name="456"/>  456:         end).
<a name="457"/>  457: 
<a name="458"/>  458: <i>%% Ensure that a new request replacing an existing long-poll does not start the</i>
<a name="459"/>  459: <i>%% inactivity timer.</i>
<a name="interrupt_long_poll_is_activity-1"/><a name="460"/>  460: <b>interrupt_long_poll_is_activity</b>(ConfigIn) -&gt;
<a name="461"/>  461:     Config = escalus_users:update_userspec(ConfigIn, carol, bosh_wait, 10),
<a name="462"/>  462: 
<a name="463"/>  463:     escalus:fresh_story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="464"/>  464: 
<a name="465"/>  465:         %% Sanity check - there should be one BOSH session belonging
<a name="466"/>  466:         %% to Carol and one handler for Carol.
<a name="467"/>  467:         Sid = get_bosh_sid(Carol),
<a name="468"/>  468:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="469"/>  469:         1 = wait_for_handler(CarolSessionPid),
<a name="470"/>  470: 
<a name="471"/>  471:         %% Send a message.  A new connection should be established, and
<a name="472"/>  472:         %% the existing long-poll connection should be closed.
<a name="473"/>  473:         escalus_client:send(Carol,
<a name="474"/>  474:                             escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="475"/>  475: 
<a name="476"/>  476:         %% Wait until after the inactivity timeout (which should be less than
<a name="477"/>  477:         %% the BOSH wait timeout).
<a name="478"/>  478:         timer:sleep(2 * timer:seconds(?INACTIVITY)),
<a name="479"/>  479: 
<a name="480"/>  480:         %% No disconnection should have occurred.
<a name="481"/>  481:         escalus_assert:has_no_stanzas(Carol),
<a name="482"/>  482:         true = is_sesssion_alive(Sid),
<a name="483"/>  483:         1 = wait_for_handler(CarolSessionPid)
<a name="484"/>  484: 
<a name="485"/>  485:         end).
<a name="486"/>  486: 
<a name="reply_on_pause-1"/><a name="487"/>  487: <b>reply_on_pause</b>(Config) -&gt;
<a name="488"/>  488:     escalus:fresh_story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="489"/>  489: 
<a name="490"/>  490:         Sid = get_bosh_sid(Carol),
<a name="491"/>  491:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="492"/>  492:         set_keepalive(Carol, false),
<a name="493"/>  493: 
<a name="494"/>  494:         %% Sanity check - there should be one handler for Carol.
<a name="495"/>  495:         1 = wait_for_handler(CarolSessionPid),
<a name="496"/>  496: 
<a name="497"/>  497:         pause(Carol, 10),
<a name="498"/>  498: 
<a name="499"/>  499:         %% There should be no handlers for Carol,
<a name="500"/>  500:         %% but the session should be alive.
<a name="501"/>  501:         true = is_sesssion_alive(Sid),
<a name="502"/>  502:         0 = length(get_handlers(CarolSessionPid)),
<a name="503"/>  503:         0 = escalus_bosh:get_requests(Carol)
<a name="504"/>  504: 
<a name="505"/>  505:         end).
<a name="506"/>  506: 
<a name="cant_pause_for_too_long-1"/><a name="507"/>  507: <b>cant_pause_for_too_long</b>(Config) -&gt;
<a name="508"/>  508:     escalus:fresh_story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="509"/>  509: 
<a name="510"/>  510:         Sid = get_bosh_sid(Carol),
<a name="511"/>  511:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="512"/>  512:         set_keepalive(Carol, false),
<a name="513"/>  513: 
<a name="514"/>  514:         %% Sanity check - there should be one handler for Carol.
<a name="515"/>  515:         1 = wait_for_handler(CarolSessionPid),
<a name="516"/>  516: 
<a name="517"/>  517:         pause(Carol, 10000),
<a name="518"/>  518: 
<a name="519"/>  519:         escalus:assert(is_stream_end, escalus:wait_for_stanza(Carol)),
<a name="520"/>  520:         false = is_sesssion_alive(Sid)
<a name="521"/>  521: 
<a name="522"/>  522:         end).
<a name="523"/>  523: 
<a name="524"/>  524: <i>%% Ensure that a pause request causes inactivity timer cancellation.</i>
<a name="pause_request_is_activity-1"/><a name="525"/>  525: <b>pause_request_is_activity</b>(Config) -&gt;
<a name="526"/>  526:     escalus:fresh_story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="527"/>  527: 
<a name="528"/>  528:         Sid = get_bosh_sid(Carol),
<a name="529"/>  529:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="530"/>  530:         set_keepalive(Carol, false),
<a name="531"/>  531: 
<a name="532"/>  532:         %% Sanity check - there should be one handler for Carol.
<a name="533"/>  533:         1 = wait_for_handler(CarolSessionPid),
<a name="534"/>  534: 
<a name="535"/>  535:         %% Wait most of the allowed inactivity interval.
<a name="536"/>  536:         timer:sleep(timer:seconds(?INACTIVITY - 1)),
<a name="537"/>  537: 
<a name="538"/>  538:         %% This should cancel the inactivity timer.
<a name="539"/>  539:         pause(Carol, 10),
<a name="540"/>  540: 
<a name="541"/>  541:         %% Wait a bit past the inactivity interval.
<a name="542"/>  542:         timer:sleep(timer:seconds(?INACTIVITY - 1)),
<a name="543"/>  543: 
<a name="544"/>  544:         %% No disconnection should've occured.
<a name="545"/>  545:         escalus_assert:has_no_stanzas(Carol),
<a name="546"/>  546:         true = is_sesssion_alive(Sid)
<a name="547"/>  547: 
<a name="548"/>  548:         end).
<a name="549"/>  549: 
<a name="reply_in_time-1"/><a name="550"/>  550: <b>reply_in_time</b>(ConfigIn) -&gt;
<a name="551"/>  551:     Config = escalus_users:update_userspec(ConfigIn, carol, bosh_wait, 1),
<a name="552"/>  552:     escalus:fresh_story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="553"/>  553: 
<a name="554"/>  554:         Wait = proplists:get_value(bosh_wait,
<a name="555"/>  555:                                    escalus_users:get_userspec(Config, carol)),
<a name="556"/>  556: 
<a name="557"/>  557:         %% Don't send new long-polling requests waiting for server push.
<a name="558"/>  558:         set_keepalive(Carol, false),
<a name="559"/>  559: 
<a name="560"/>  560:         %% Make Carol receive using the last remaining connection.
<a name="561"/>  561:         escalus_client:send(Geralt,
<a name="562"/>  562:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="563"/>  563:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="564"/>  564:                        escalus_client:wait_for_stanza(Carol)),
<a name="565"/>  565: 
<a name="566"/>  566:         %% Sanity check - there should be no awaiting handlers.
<a name="567"/>  567:         {_, _, CarolSessionPid} = get_bosh_session(get_bosh_sid(Carol)),
<a name="568"/>  568:         0 = length(get_handlers(CarolSessionPid)),
<a name="569"/>  569: 
<a name="570"/>  570:         %% Send a single request and assert it's registered by server.
<a name="571"/>  571:         Rid = get_bosh_rid(Carol),
<a name="572"/>  572:         Sid = get_bosh_sid(Carol),
<a name="573"/>  573:         Empty = escalus_bosh:empty_body(Rid, Sid),
<a name="574"/>  574:         escalus_bosh:send_raw(Carol, Empty),
<a name="575"/>  575:         timer:sleep(100),
<a name="576"/>  576:         1 = wait_for_handler(CarolSessionPid),
<a name="577"/>  577: 
<a name="578"/>  578:         timer:sleep(timer:seconds(Wait) + 100),
<a name="579"/>  579: 
<a name="580"/>  580:         %% Assert the server has responded to that request.
<a name="581"/>  581:         0 = length(get_handlers(CarolSessionPid))
<a name="582"/>  582: 
<a name="583"/>  583:         end).
<a name="584"/>  584: 
<a name="server_acks-1"/><a name="585"/>  585: <b>server_acks</b>(Config) -&gt;
<a name="586"/>  586:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="587"/>  587: 
<a name="588"/>  588:         escalus_bosh:set_active(Carol, false),
<a name="589"/>  589:         ExpectedRid = list_to_binary(integer_to_list(get_bosh_rid(Carol))),
<a name="590"/>  590:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st!&quot;&gt;&gt;)),
<a name="591"/>  591:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd!&quot;&gt;&gt;)),
<a name="592"/>  592:         timer:sleep(200),
<a name="593"/>  593: 
<a name="594"/>  594:         All = recv_all(Carol),
<a name="595"/>  595:         ExpectedRid = exml_query:attr(hd(All), &lt;&lt;&quot;ack&quot;&gt;&gt;)
<a name="596"/>  596: 
<a name="597"/>  597:         end).
<a name="598"/>  598: 
<a name="force_report-1"/><a name="599"/>  599: <b>force_report</b>(Config) -&gt;
<a name="600"/>  600: 
<a name="601"/>  601:     %% Carol stores current Rid1
<a name="602"/>  602:     %% Carol sends msg1
<a name="603"/>  603:     %% Carol sends msg2
<a name="604"/>  604:     %% Geralt sends a reply to msg1
<a name="605"/>  605:     %% Geralt sends a reply to msg2
<a name="606"/>  606:     %% Carol recvs a reply to msg1
<a name="607"/>  607:     %% Carol recvs a reply to msg2
<a name="608"/>  608:     %% Carol sends an ack with Rid1 on empty BOSH wrapper
<a name="609"/>  609:     %% server sends a report
<a name="610"/>  610: 
<a name="611"/>  611:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="612"/>  612: 
<a name="613"/>  613:         StaleRid = get_bosh_rid(Carol),
<a name="614"/>  614:         escalus_client:send(Carol, chat_to(Geralt, &lt;&lt;&quot;1st msg&quot;&gt;&gt;)),
<a name="615"/>  615:         escalus_client:send(Carol, chat_to(Geralt, &lt;&lt;&quot;2nd msg&quot;&gt;&gt;)),
<a name="616"/>  616:         wait_for_stanzas(Geralt, 2),
<a name="617"/>  617:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep&quot;&gt;&gt;)),
<a name="618"/>  618:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;2nd rep&quot;&gt;&gt;)),
<a name="619"/>  619:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep&quot;&gt;&gt;],
<a name="620"/>  620:                        wait_for_stanza(Carol)),
<a name="621"/>  621:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd rep&quot;&gt;&gt;],
<a name="622"/>  622:                        wait_for_stanza(Carol)),
<a name="623"/>  623: 
<a name="624"/>  624:         %% Turn on client acknowledgement checking for Carol
<a name="625"/>  625:         {_, _, CarolSessionPid} = get_bosh_session(get_bosh_sid(Carol)),
<a name="626"/>  626:         set_client_acks(CarolSessionPid, true),
<a name="627"/>  627: 
<a name="628"/>  628:         escalus_bosh:set_active(Carol, false),
<a name="629"/>  629:         %% Send ack with StaleRid
<a name="630"/>  630:         Rid = get_bosh_rid(Carol),
<a name="631"/>  631:         Sid = get_bosh_sid(Carol),
<a name="632"/>  632:         BodyWithAck = ack_body(escalus_bosh:empty_body(Rid, Sid), StaleRid),
<a name="633"/>  633:         escalus_bosh:send_raw(Carol, BodyWithAck),
<a name="634"/>  634: 
<a name="635"/>  635:         %% Turn off client acknowledgement checking - don't cause server error
<a name="636"/>  636:         %% on subsequent requests without 'ack' attribute.
<a name="637"/>  637:         set_client_acks(CarolSessionPid, false),
<a name="638"/>  638: 
<a name="639"/>  639:         %% Expect a server report
<a name="640"/>  640:         timer:sleep(100),
<a name="641"/>  641:         MaybeReport = bosh_recv(Carol),
<a name="642"/>  642:         escalus:assert(is_bosh_report, [StaleRid+1], MaybeReport)
<a name="643"/>  643: 
<a name="644"/>  644:         end).
<a name="645"/>  645: 
<a name="force_retransmission-1"/><a name="646"/>  646: <b>force_retransmission</b>(Config) -&gt;
<a name="647"/>  647:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="648"/>  648: 
<a name="649"/>  649:         %% `send_raw` must be used as the exact request structure
<a name="650"/>  650:         %% is needed later for retransmission.
<a name="651"/>  651:         %% Hence, construct the request manually.
<a name="652"/>  652:         Rid = get_bosh_rid(Carol),
<a name="653"/>  653:         Sid = get_bosh_sid(Carol),
<a name="654"/>  654:         Empty = escalus_bosh:empty_body(Rid, Sid),
<a name="655"/>  655:         Chat = Empty#xmlel{
<a name="656"/>  656:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st msg!&quot;&gt;&gt;)]},
<a name="657"/>  657: 
<a name="658"/>  658:         %% Send msg, recv msg, send reply, recv reply.
<a name="659"/>  659:         %% This synchronous sequence sets up the server
<a name="660"/>  660:         %% to have the reply for Chat cached.
<a name="661"/>  661:         escalus_bosh:send_raw(Carol, Chat),
<a name="662"/>  662:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st msg!&quot;&gt;&gt;],
<a name="663"/>  663:                        wait_for_stanza(Geralt)),
<a name="664"/>  664:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep!&quot;&gt;&gt;)),
<a name="665"/>  665:         ChatResponse = wait_for_stanza(Carol),
<a name="666"/>  666:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep!&quot;&gt;&gt;], ChatResponse),
<a name="667"/>  667: 
<a name="668"/>  668:         %% Resend msg.
<a name="669"/>  669:         escalus_bosh:resend_raw(Carol, Chat),
<a name="670"/>  670: 
<a name="671"/>  671:         %% Recv same reply again.
<a name="672"/>  672:         ChatResponse = wait_for_stanza(Carol)
<a name="673"/>  673: 
<a name="674"/>  674:         end).
<a name="675"/>  675: 
<a name="force_cache_trimming-1"/><a name="676"/>  676: <b>force_cache_trimming</b>(Config) -&gt;
<a name="677"/>  677:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="678"/>  678: 
<a name="679"/>  679:         Sid = get_bosh_sid(Carol),
<a name="680"/>  680: 
<a name="681"/>  681:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="682"/>  682:         set_client_acks(CarolSessionPid, true),
<a name="683"/>  683: 
<a name="684"/>  684:         %% Ack now
<a name="685"/>  685:         Rid1 = get_bosh_rid(Carol),
<a name="686"/>  686:         Ack1 = ack_body(escalus_bosh:empty_body(Rid1, Sid), Rid1-1),
<a name="687"/>  687:         escalus_bosh:send_raw(Carol, Ack1),
<a name="688"/>  688: 
<a name="689"/>  689:         %% Exchange 2 messages
<a name="690"/>  690:         Rid2 = get_bosh_rid(Carol),
<a name="691"/>  691:         Chat = (escalus_bosh:empty_body(Rid2, Sid))#xmlel{
<a name="692"/>  692:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st msg!&quot;&gt;&gt;)]},
<a name="693"/>  693:         escalus_bosh:send_raw(Carol, Chat),
<a name="694"/>  694:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st msg!&quot;&gt;&gt;],
<a name="695"/>  695:                        wait_for_stanza(Geralt)),
<a name="696"/>  696:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep!&quot;&gt;&gt;)),
<a name="697"/>  697:         ChatResponse = wait_for_stanza(Carol),
<a name="698"/>  698:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep!&quot;&gt;&gt;], ChatResponse),
<a name="699"/>  699: 
<a name="700"/>  700:         %% Ack/Chat again
<a name="701"/>  701:         Rid3 = get_bosh_rid(Carol),
<a name="702"/>  702:         AckedChat = (ack_body(escalus_bosh:empty_body(Rid3, Sid), Rid2))#xmlel{
<a name="703"/>  703:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd msg!&quot;&gt;&gt;)]},
<a name="704"/>  704:         escalus_bosh:send_raw(Carol, AckedChat),
<a name="705"/>  705:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd msg!&quot;&gt;&gt;],
<a name="706"/>  706:                        wait_for_stanza(Geralt)),
<a name="707"/>  707: 
<a name="708"/>  708:         %% The cache should now contain only entries newer than Rid2.
<a name="709"/>  709:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="710"/>  710:         Cache = get_cached_responses(CarolSessionPid),
<a name="711"/>  711:         true = lists:all(fun({R,_,_}) when R &gt; Rid2 -&gt; true; (_) -&gt; false end,
<a name="712"/>  712:                          Cache),
<a name="713"/>  713:         %% Not sure about this one...
<a name="714"/>  714:         1 = length(Cache),
<a name="715"/>  715: 
<a name="716"/>  716:         set_client_acks(CarolSessionPid, false)
<a name="717"/>  717: 
<a name="718"/>  718:         end).
<a name="719"/>  719: 
<a name="720"/>  720: <i>%%--------------------------------------------------------------------</i>
<a name="721"/>  721: <i>%% Helpers</i>
<a name="722"/>  722: <i>%%--------------------------------------------------------------------</i>
<a name="723"/>  723: 
<a name="get_bosh_sessions-0"/><a name="724"/>  724: <b>get_bosh_sessions</b>() -&gt;
<a name="725"/>  725:     Backend = escalus_ejabberd:rpc(mod_bosh_dynamic, backend, []),
<a name="726"/>  726:     escalus_ejabberd:rpc(Backend, get_sessions, []).
<a name="727"/>  727: 
<a name="get_bosh_session-1"/><a name="728"/>  728: <b>get_bosh_session</b>(Sid) -&gt;
<a name="729"/>  729:     BoshSessions = get_bosh_sessions(),
<a name="730"/>  730:     lists:keyfind(Sid, 2, BoshSessions).
<a name="731"/>  731: 
<a name="get_handlers-1"/><a name="732"/>  732: <b>get_handlers</b>(BoshSessionPid) -&gt;
<a name="733"/>  733:     escalus_ejabberd:rpc(mod_bosh_socket, get_handlers, [BoshSessionPid]).
<a name="734"/>  734: 
<a name="get_bosh_sid-1"/><a name="735"/>  735: <b>get_bosh_sid</b>(#client{} = Client) -&gt;
<a name="736"/>  736:     escalus_bosh:get_sid(Client).
<a name="737"/>  737: 
<a name="get_bosh_rid-1"/><a name="738"/>  738: <b>get_bosh_rid</b>(#client{} = C) -&gt;
<a name="739"/>  739:     escalus_bosh:get_rid(C).
<a name="740"/>  740: 
<a name="set_keepalive-2"/><a name="741"/>  741: <b>set_keepalive</b>(#client{} = C, Keepalive) -&gt;
<a name="742"/>  742:     escalus_bosh:set_keepalive(C, Keepalive).
<a name="743"/>  743: 
<a name="mark_as_terminated-1"/><a name="744"/>  744: <b>mark_as_terminated</b>(#client{} = C) -&gt;
<a name="745"/>  745:     escalus_bosh:mark_as_terminated(C).
<a name="746"/>  746: 
<a name="pause-2"/><a name="747"/>  747: <b>pause</b>(#client{} = C, Seconds) -&gt;
<a name="748"/>  748:     escalus_bosh:pause(C, Seconds),
<a name="749"/>  749:     timer:sleep(100).
<a name="750"/>  750: 
<a name="start_client-3"/><a name="751"/>  751: <b>start_client</b>(Config, User, Res) -&gt;
<a name="752"/>  752:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="753"/>  753:     UserSpec = [{keepalive, false} | proplists:get_value(User, NamedSpecs)],
<a name="754"/>  754:     {ok, Client} = escalus_client:start(Config, UserSpec, Res),
<a name="755"/>  755:     Client.
<a name="756"/>  756: 
<a name="recv_all-1"/><a name="757"/>  757: <b>recv_all</b>(Client) -&gt;
<a name="758"/>  758:     recv_all(bosh_recv(Client), Client, []).
<a name="759"/>  759: 
<a name="recv_all-3"/><a name="760"/>  760: <b>recv_all</b>(empty, _Client, Acc) -&gt;
<a name="761"/>  761:     lists:reverse(Acc);
<a name="762"/>  762: <b>recv_all</b>(Element, Client, Acc) -&gt;
<a name="763"/>  763:     recv_all(bosh_recv(Client), Client, [Element | Acc]).
<a name="764"/>  764: 
<a name="bosh_recv-1"/><a name="765"/>  765: <b>bosh_recv</b>(#client{} = C) -&gt;
<a name="766"/>  766:     escalus_bosh:recv(C).
<a name="767"/>  767: 
<a name="chat_to-2"/><a name="768"/>  768: <b>chat_to</b>(Client, Content) -&gt;
<a name="769"/>  769:     escalus_stanza:chat_to(Client, Content).
<a name="770"/>  770: 
<a name="wait_for_stanzas-2"/><a name="771"/>  771: <b>wait_for_stanzas</b>(Client, Count) -&gt;
<a name="772"/>  772:     escalus_client:wait_for_stanzas(Client, Count).
<a name="773"/>  773: 
<a name="wait_for_stanza-1"/><a name="774"/>  774: <b>wait_for_stanza</b>(Client) -&gt;
<a name="775"/>  775:     escalus_client:wait_for_stanza(Client).
<a name="776"/>  776: 
<a name="wait_for_close-2"/><a name="777"/>  777: <b>wait_for_close</b>(Client, 0) -&gt;
<a name="778"/>  778:     false == escalus_connection:is_connected(Client);
<a name="779"/>  779: <b>wait_for_close</b>(Client, N) -&gt;
<a name="780"/>  780:     case escalus_connection:is_connected(Client) of
<a name="781"/>  781:         false -&gt;
<a name="782"/>  782:             true;
<a name="783"/>  783:         _ -&gt;
<a name="784"/>  784:             timer:sleep(100),
<a name="785"/>  785:             wait_for_close(Client, N-1)
<a name="786"/>  786:     end.
<a name="787"/>  787: 
<a name="ack_body-2"/><a name="788"/>  788: <b>ack_body</b>(Body, Rid) -&gt;
<a name="789"/>  789:     Attrs = Body#xmlel.attrs,
<a name="790"/>  790:     Ack = {&lt;&lt;&quot;ack&quot;&gt;&gt;, list_to_binary(integer_to_list(Rid))},
<a name="791"/>  791:     NewAttrs = lists:keystore(&lt;&lt;&quot;ack&quot;&gt;&gt;, 1, Attrs, Ack),
<a name="792"/>  792:     Body#xmlel{attrs = NewAttrs}.
<a name="793"/>  793: 
<a name="set_client_acks-2"/><a name="794"/>  794: <b>set_client_acks</b>(SessionPid, Enabled) -&gt;
<a name="795"/>  795:     escalus_ejabberd:rpc(mod_bosh_socket, set_client_acks,
<a name="796"/>  796:                          [SessionPid, Enabled]).
<a name="797"/>  797: 
<a name="get_cached_responses-1"/><a name="798"/>  798: <b>get_cached_responses</b>(SessionPid) -&gt;
<a name="799"/>  799:     escalus_ejabberd:rpc(mod_bosh_socket, get_cached_responses, [SessionPid]).
<a name="800"/>  800: 
<a name="inactivity-0"/><a name="801"/>  801: <b>inactivity</b>() -&gt;
<a name="802"/>  802:     inactivity(?INACTIVITY).
<a name="803"/>  803: 
<a name="inactivity-1"/><a name="804"/>  804: <b>inactivity</b>(Value) -&gt;
<a name="805"/>  805:     {inactivity,
<a name="806"/>  806:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_inactivity, []) end,
<a name="807"/>  807:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_inactivity, [V]) end,
<a name="808"/>  808:      Value}.
<a name="809"/>  809: 
<a name="max_wait-0"/><a name="810"/>  810: <b>max_wait</b>() -&gt;
<a name="811"/>  811:     max_wait(?MAX_WAIT).
<a name="812"/>  812: 
<a name="max_wait-1"/><a name="813"/>  813: <b>max_wait</b>(Value) -&gt;
<a name="814"/>  814:     {max_wait,
<a name="815"/>  815:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_max_wait, []) end,
<a name="816"/>  816:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_max_wait, [V]) end,
<a name="817"/>  817:      Value}.
<a name="818"/>  818: 
<a name="server_acks_opt-0"/><a name="819"/>  819: <b>server_acks_opt</b>() -&gt;
<a name="820"/>  820:     {server_acks,
<a name="821"/>  821:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_server_acks, []) end,
<a name="822"/>  822:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_server_acks, [V]) end,
<a name="823"/>  823:      true}.
<a name="824"/>  824: 
<a name="is_sesssion_alive-1"/><a name="825"/>  825: <b>is_sesssion_alive</b>(Sid) -&gt;
<a name="826"/>  826:     BoshSessions = get_bosh_sessions(),
<a name="827"/>  827:     lists:keymember(Sid, 2, BoshSessions).
<a name="828"/>  828: 
<a name="wait_for_session_close-2"/><a name="829"/>  829: <b>wait_for_session_close</b>(Sid, 0) -&gt;
<a name="830"/>  830:     false == is_sesssion_alive(Sid);
<a name="831"/>  831: <b>wait_for_session_close</b>(Sid, N) -&gt;
<a name="832"/>  832:     case is_sesssion_alive(Sid) of
<a name="833"/>  833:         false -&gt;
<a name="834"/>  834:             true;
<a name="835"/>  835:         _ -&gt;
<a name="836"/>  836:             timer:sleep(100),
<a name="837"/>  837:             wait_for_session_close(Sid, N-1)
<a name="838"/>  838:     end.
<a name="839"/>  839: 
<a name="wait_for_handler-1"/><a name="840"/>  840: <b>wait_for_handler</b>(Pid) -&gt;
<a name="841"/>  841:     wait_for_handler(Pid, 10).
<a name="842"/>  842: 
<a name="wait_for_handler-2"/><a name="843"/>  843: <b>wait_for_handler</b>(Pid, 0) -&gt;
<a name="844"/>  844:     length(get_handlers(Pid));
<a name="845"/>  845: <b>wait_for_handler</b>(Pid, N) -&gt;
<a name="846"/>  846:     case get_handlers(Pid) of
<a name="847"/>  847:         [] -&gt;
<a name="848"/>  848:             timer:sleep(50),
<a name="849"/>  849:             wait_for_handler(Pid, N-1);
<a name="850"/>  850:         L -&gt;
<a name="851"/>  851:             length(L)
<a name="852"/>  852:     end.
</pre>
</body>
</html>
