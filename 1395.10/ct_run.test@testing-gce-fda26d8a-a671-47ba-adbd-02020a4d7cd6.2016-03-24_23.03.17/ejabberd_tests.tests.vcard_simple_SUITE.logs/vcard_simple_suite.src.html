<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<title>/home/travis/build/esl/MongooseIM/test/ejabberd_tests/tests/vcard_simple_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%==============================================================================</i>
<a name="2"/>    2: <i>%% Copyright 2013 Erlang Solutions Ltd.</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Test the mod_vcard running on the server.</i>
<a name="5"/>    5: <i>%%</i>
<a name="6"/>    6: <i>%%</i>
<a name="7"/>    7: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="8"/>    8: <i>%% you may not use this file except in compliance with the License.</i>
<a name="9"/>    9: <i>%% You may obtain a copy of the License at</i>
<a name="10"/>   10: <i>%%</i>
<a name="11"/>   11: <i>%% http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="12"/>   12: <i>%%</i>
<a name="13"/>   13: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="14"/>   14: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="15"/>   15: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="16"/>   16: <i>%% See the License for the specific language governing permissions and</i>
<a name="17"/>   17: <i>%% limitations under the License.</i>
<a name="18"/>   18: <i>%%==============================================================================</i>
<a name="19"/>   19: 
<a name="20"/>   20: <b>-module</b>(vcard_simple_SUITE).
<a name="21"/>   21: <b>-compile</b>(export_all).
<a name="22"/>   22: 
<a name="23"/>   23: <b>-include_lib</b>(&quot;escalus/include/escalus_xmlns.hrl&quot;).
<a name="24"/>   24: <b>-include_lib</b>(&quot;escalus/include/escalus.hrl&quot;).
<a name="25"/>   25: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="26"/>   26: <b>-include_lib</b>(&quot;exml/include/exml.hrl&quot;).
<a name="27"/>   27: 
<a name="28"/>   28: <i>%% Element CData</i>
<a name="29"/>   29: <b>-define</b>(EL(Element, Name), exml_query:path(Element, [{element, Name}])).
<a name="30"/>   30: <b>-define</b>(EL_CD(Element, Name), exml_query:path(Element, [{element, Name}, cdata])).
<a name="31"/>   31: 
<a name="32"/>   32: 
<a name="33"/>   33: <i>%%--------------------------------------------------------------------</i>
<a name="34"/>   34: <i>%% Suite configuration</i>
<a name="35"/>   35: <i>%%--------------------------------------------------------------------</i>
<a name="36"/>   36: 
<a name="all-0"/><a name="37"/>   37: <b>all</b>() -&gt;
<a name="38"/>   38:     [{group, all}
<a name="39"/>   39:     ].
<a name="40"/>   40: 
<a name="groups-0"/><a name="41"/>   41: <b>groups</b>() -&gt;
<a name="42"/>   42:     %% setting test data before tests is proving awkward so might as well use the
<a name="43"/>   43:     %% data set in the update tests to test the rest.
<a name="44"/>   44:     [{all, [sequence], all_tests()}
<a name="45"/>   45:     ].
<a name="46"/>   46: 
<a name="all_tests-0"/><a name="47"/>   47: <b>all_tests</b>() -&gt;
<a name="48"/>   48:     [update_own_card,
<a name="49"/>   49:      retrieve_own_card,
<a name="50"/>   50:      user_doesnt_exist,
<a name="51"/>   51:      update_other_card,
<a name="52"/>   52:      retrieve_others_card,
<a name="53"/>   53:      request_search_fields,
<a name="54"/>   54:      search_empty,
<a name="55"/>   55:      search_some,
<a name="56"/>   56:      search_wildcard].
<a name="57"/>   57: 
<a name="suite-0"/><a name="58"/>   58: <b>suite</b>() -&gt;
<a name="59"/>   59:     escalus:suite().
<a name="60"/>   60: 
<a name="61"/>   61: 
<a name="62"/>   62: <i>%%--------------------------------------------------------------------</i>
<a name="63"/>   63: <i>%% Init &amp; teardown</i>
<a name="64"/>   64: <i>%%--------------------------------------------------------------------</i>
<a name="65"/>   65: 
<a name="init_per_suite-1"/><a name="66"/>   66: <b>init_per_suite</b>(Config) -&gt;
<a name="67"/>   67:     NewConfig0 = escalus:init_per_suite(Config),
<a name="68"/>   68:     NewConfig = case is_vcard_ldap() of
<a name="69"/>   69:         true -&gt;
<a name="70"/>   70:             configure_ldap_vcards(NewConfig0);
<a name="71"/>   71:         _ -&gt;
<a name="72"/>   72:             NewConfig0
<a name="73"/>   73:     end,
<a name="74"/>   74:     escalus:create_users(NewConfig, escalus:get_users([alice, bob])).
<a name="75"/>   75: 
<a name="end_per_suite-1"/><a name="76"/>   76: <b>end_per_suite</b>(Config) -&gt;
<a name="77"/>   77:     NewConfig = escalus:delete_users(Config, escalus:get_users([alice, bob])),
<a name="78"/>   78:     case is_vcard_ldap() of
<a name="79"/>   79:         true -&gt;
<a name="80"/>   80:             restore_ldap_vcards_config(Config);
<a name="81"/>   81:         _ -&gt;
<a name="82"/>   82:             ok
<a name="83"/>   83:     end,
<a name="84"/>   84:     escalus:end_per_suite(NewConfig).
<a name="85"/>   85: 
<a name="init_per_group-2"/><a name="86"/>   86: <b>init_per_group</b>(_GN, Config) -&gt;
<a name="87"/>   87:     Config.
<a name="88"/>   88: 
<a name="end_per_group-2"/><a name="89"/>   89: <b>end_per_group</b>(_, Config) -&gt;
<a name="90"/>   90:     Config.
<a name="91"/>   91: 
<a name="init_per_testcase-2"/><a name="92"/>   92: <b>init_per_testcase</b>(CaseName, Config) -&gt;
<a name="93"/>   93:     escalus:init_per_testcase(CaseName, Config).
<a name="94"/>   94: 
<a name="end_per_testcase-2"/><a name="95"/>   95: <b>end_per_testcase</b>(CaseName, Config) -&gt;
<a name="96"/>   96:     escalus:end_per_testcase(CaseName, Config).
<a name="97"/>   97: 
<a name="98"/>   98: 
<a name="99"/>   99: <i>%%--------------------------------------------------------------------</i>
<a name="100"/>  100: <i>%% XEP-0054: vcard-temp Test cases</i>
<a name="101"/>  101: <i>%%--------------------------------------------------------------------</i>
<a name="102"/>  102: 
<a name="update_own_card-1"/><a name="103"/>  103: <b>update_own_card</b>(Config) -&gt;
<a name="104"/>  104:     case is_vcard_ldap() of
<a name="105"/>  105:         true -&gt;
<a name="106"/>  106:             {skip,ldap_vcard_is_readonly};
<a name="107"/>  107:         _ -&gt;
<a name="108"/>  108:             escalus:story(
<a name="109"/>  109:               Config, [{alice, 1}],
<a name="110"/>  110:               fun(Client1) -&gt;
<a name="111"/>  111:                       %% set some initial value different from the actual test data
<a name="112"/>  112:                       %% so we know it really got updated and wasn't just old data
<a name="113"/>  113:                       FN = get_FN(Config),
<a name="114"/>  114:                       Client1Fields = [{&lt;&lt;&quot;FN&quot;&gt;&gt;, FN}],
<a name="115"/>  115:                       Client1SetResultStanza
<a name="116"/>  116:                       = escalus:send_and_wait(Client1,
<a name="117"/>  117:                                               escalus_stanza:vcard_update(Client1Fields)),
<a name="118"/>  118:                       escalus:assert(is_iq_result, Client1SetResultStanza),
<a name="119"/>  119:                       escalus_stanza:vcard_request(),
<a name="120"/>  120:                       Client1GetResultStanza
<a name="121"/>  121:                       = escalus:send_and_wait(Client1, escalus_stanza:vcard_request()),
<a name="122"/>  122:                       FN
<a name="123"/>  123:                       = stanza_get_vcard_field_cdata(Client1GetResultStanza, &lt;&lt;&quot;FN&quot;&gt;&gt;)
<a name="124"/>  124:               end)
<a name="125"/>  125:     end.
<a name="126"/>  126: 
<a name="retrieve_own_card-1"/><a name="127"/>  127: <b>retrieve_own_card</b>(Config) -&gt;
<a name="128"/>  128:     escalus:story(
<a name="129"/>  129:       Config, [{alice, 1}],
<a name="130"/>  130:       fun(Client) -&gt;
<a name="131"/>  131:               Res = escalus:send_and_wait(Client,
<a name="132"/>  132:                         escalus_stanza:vcard_request()),
<a name="133"/>  133:               ClientVCardTups = [{&lt;&lt;&quot;FN&quot;&gt;&gt;, get_FN(Config)}],
<a name="134"/>  134:               check_vcard(ClientVCardTups, Res)
<a name="135"/>  135:       end).
<a name="136"/>  136: 
<a name="137"/>  137: 
<a name="138"/>  138: 
<a name="139"/>  139: <i>%% If no vCard exists or the user does not exist, the server MUST</i>
<a name="140"/>  140: <i>%% return a stanza error, which SHOULD be either</i>
<a name="141"/>  141: <i>%% &lt;service-unavailable/&gt; or &lt;item-not-found/&gt;</i>
<a name="user_doesnt_exist-1"/><a name="142"/>  142: <b>user_doesnt_exist</b>(Config) -&gt;
<a name="143"/>  143:     escalus:story(
<a name="144"/>  144:       Config, [{alice, 1}],
<a name="145"/>  145:       fun(Client) -&gt;
<a name="146"/>  146:               Domain = escalus_config:get_ct(ejabberd_domain),
<a name="147"/>  147:               BadJID = &lt;&lt;&quot;nonexistent@&quot;,Domain/binary&gt;&gt;,
<a name="148"/>  148:               Res = escalus:send_and_wait(Client,
<a name="149"/>  149:                         escalus_stanza:vcard_request(BadJID)),
<a name="150"/>  150:                 case
<a name="151"/>  151:                   escalus_pred:is_error(&lt;&lt;&quot;cancel&quot;&gt;&gt;,
<a name="152"/>  152:                                         &lt;&lt;&quot;service-unavailable&quot;&gt;&gt;,
<a name="153"/>  153:                                         Res) of
<a name="154"/>  154:                   true -&gt;
<a name="155"/>  155:                       ok;
<a name="156"/>  156:                   _ -&gt;
<a name="157"/>  157:                       [] = Res#xmlel.children,
<a name="158"/>  158:                       ct:comment(&quot;empty result instead of error&quot;)
<a name="159"/>  159:               end
<a name="160"/>  160:       end).
<a name="161"/>  161: 
<a name="update_other_card-1"/><a name="162"/>  162: <b>update_other_card</b>(Config) -&gt;
<a name="163"/>  163:     escalus:story(
<a name="164"/>  164:       Config, [{alice, 1}, {bob, 1}],
<a name="165"/>  165:       fun(Client, OtherClient) -&gt;
<a name="166"/>  166:               JID = escalus_client:short_jid(Client),
<a name="167"/>  167:               Fields = [{&lt;&lt;&quot;FN&quot;&gt;&gt;, &lt;&lt;&quot;New name&quot;&gt;&gt;}],
<a name="168"/>  168:               Res = escalus:send_and_wait(OtherClient,
<a name="169"/>  169:                         escalus_stanza:vcard_update(JID, Fields)),
<a name="170"/>  170: 
<a name="171"/>  171:               %% check that nothing was changed
<a name="172"/>  172:               Res2 = escalus:send_and_wait(Client,
<a name="173"/>  173:                         escalus_stanza:vcard_request()),
<a name="174"/>  174:               ClientVCardTups = [{&lt;&lt;&quot;FN&quot;&gt;&gt;, get_FN(Config)}],
<a name="175"/>  175:               check_vcard(ClientVCardTups, Res2),
<a name="176"/>  176: 
<a name="177"/>  177:               case escalus_pred:is_error(&lt;&lt;&quot;cancel&quot;&gt;&gt;,
<a name="178"/>  178:                                         &lt;&lt;&quot;not-allowed&quot;&gt;&gt;, Res) of
<a name="179"/>  179:                   true -&gt;
<a name="180"/>  180:                       ok;
<a name="181"/>  181:                   _ -&gt;
<a name="182"/>  182:                         ct:comment(&quot;no error returned&quot;)
<a name="183"/>  183:               end
<a name="184"/>  184:       end).
<a name="185"/>  185: 
<a name="retrieve_others_card-1"/><a name="186"/>  186: <b>retrieve_others_card</b>(Config) -&gt;
<a name="187"/>  187:     escalus:story(
<a name="188"/>  188:       Config, [{alice, 1}, {bob, 1}],
<a name="189"/>  189:       fun(Client, OtherClient) -&gt;
<a name="190"/>  190:               JID = escalus_client:short_jid(Client),
<a name="191"/>  191:               Res = escalus:send_and_wait(OtherClient,
<a name="192"/>  192:                         escalus_stanza:vcard_request(JID)),
<a name="193"/>  193:               OtherClientVCardTups = [{&lt;&lt;&quot;FN&quot;&gt;&gt;, get_FN(Config)}],
<a name="194"/>  194:               check_vcard(OtherClientVCardTups, Res),
<a name="195"/>  195: 
<a name="196"/>  196:               %% In accordance with XMPP Core [5], a compliant server MUST
<a name="197"/>  197:               %% respond on behalf of the requestor and not forward the IQ to
<a name="198"/>  198:               %% the requestee's connected resource.
<a name="199"/>  199: 
<a name="200"/>  200:               Res2 = (catch escalus:wait_for_stanza(Client)),
<a name="201"/>  201:               escalus:assert(stanza_timeout, Res2)
<a name="202"/>  202:       end).
<a name="203"/>  203: 
<a name="204"/>  204: <i>%%--------------------------------------------------------------------</i>
<a name="205"/>  205: <i>%% XEP-0055 jabber:iq:search User Directory service Test cases</i>
<a name="206"/>  206: <i>%%</i>
<a name="207"/>  207: <i>%%--------------------------------------------------------------------</i>
<a name="208"/>  208: 
<a name="209"/>  209: <i>%% all.search.domain</i>
<a name="210"/>  210: 
<a name="request_search_fields-1"/><a name="211"/>  211: <b>request_search_fields</b>(Config) -&gt;
<a name="212"/>  212:     escalus:story(
<a name="213"/>  213:       Config, [{alice, 1}],
<a name="214"/>  214:       fun(Client) -&gt;
<a name="215"/>  215:               Domain = escalus_config:get_ct(ejabberd_domain),
<a name="216"/>  216:               DirJID = &lt;&lt;&quot;vjud.&quot;,Domain/binary&gt;&gt;,
<a name="217"/>  217:               Res = escalus:send_and_wait(Client,
<a name="218"/>  218:                                           escalus_stanza:search_fields_iq(DirJID)),
<a name="219"/>  219:               escalus:assert(is_iq_result, Res),
<a name="220"/>  220:               Result = ?EL(Res, &lt;&lt;&quot;query&quot;&gt;&gt;),
<a name="221"/>  221:               XData = ?EL(Result, &lt;&lt;&quot;x&quot;&gt;&gt;),
<a name="222"/>  222:               #xmlel{ children = XChildren } = XData,
<a name="223"/>  223:               FieldTups = field_tuples(XChildren),
<a name="224"/>  224:               true = lists:member({&lt;&lt;&quot;text-single&quot;&gt;&gt;,
<a name="225"/>  225:                                    get_field_name(user), &lt;&lt;&quot;User&quot;&gt;&gt;},
<a name="226"/>  226:                                   FieldTups),
<a name="227"/>  227:               true = lists:member({&lt;&lt;&quot;text-single&quot;&gt;&gt;,
<a name="228"/>  228:                                    get_field_name(fn),
<a name="229"/>  229:                                    &lt;&lt;&quot;Full Name&quot;&gt;&gt;},
<a name="230"/>  230:                                   FieldTups)
<a name="231"/>  231: 
<a name="232"/>  232:       end).
<a name="233"/>  233: 
<a name="search_empty-1"/><a name="234"/>  234: <b>search_empty</b>(Config) -&gt;
<a name="235"/>  235:     escalus:story(
<a name="236"/>  236:       Config, [{alice, 1}],
<a name="237"/>  237:       fun(Client) -&gt;
<a name="238"/>  238:               Domain = escalus_config:get_ct(ejabberd_domain),
<a name="239"/>  239:               DirJID = &lt;&lt;&quot;vjud.&quot;,Domain/binary&gt;&gt;,
<a name="240"/>  240:               Fields = [{get_field_name(fn), &lt;&lt;&quot;nobody&quot;&gt;&gt;}],
<a name="241"/>  241:               Res = escalus:send_and_wait(Client,
<a name="242"/>  242:                                           escalus_stanza:search_iq(DirJID,
<a name="243"/>  243:                                                                    escalus_stanza:search_fields(Fields))),
<a name="244"/>  244:               escalus:assert(is_iq_result, Res),
<a name="245"/>  245:               [] = search_result_item_tuples(Res)
<a name="246"/>  246:       end).
<a name="247"/>  247: 
<a name="search_some-1"/><a name="248"/>  248: <b>search_some</b>(Config) -&gt;
<a name="249"/>  249: 
<a name="250"/>  250:     escalus:story(
<a name="251"/>  251:       Config, [{bob, 1}],
<a name="252"/>  252:       fun(Client) -&gt;
<a name="253"/>  253:               Domain = escalus_config:get_ct(ejabberd_domain),
<a name="254"/>  254:               DirJID = &lt;&lt;&quot;vjud.&quot;,Domain/binary&gt;&gt;,
<a name="255"/>  255:               Fields = [{get_field_name(fn), get_FN(Config)}],
<a name="256"/>  256:               timer:sleep(timer:seconds(1)), %% this is required by Riak 2.0 Search to be sure the vcard is indexed
<a name="257"/>  257:               Res = escalus:send_and_wait(Client,
<a name="258"/>  258:                                           escalus_stanza:search_iq(DirJID,
<a name="259"/>  259:                                                                    escalus_stanza:search_fields(Fields))),
<a name="260"/>  260:               escalus:assert(is_iq_result, Res),
<a name="261"/>  261: 
<a name="262"/>  262:               %% Basically test that the right values exist
<a name="263"/>  263:               %% and map to the right column headings
<a name="264"/>  264:               ItemTups = search_result_item_tuples(Res),
<a name="265"/>  265:               1 = length(ItemTups)
<a name="266"/>  266:       end).
<a name="267"/>  267: 
<a name="search_wildcard-1"/><a name="268"/>  268: <b>search_wildcard</b>(Config) -&gt;
<a name="269"/>  269:     escalus:story(
<a name="270"/>  270:       Config, [{bob, 1}],
<a name="271"/>  271:       fun(Client) -&gt;
<a name="272"/>  272:               Domain = escalus_config:get_ct(ejabberd_domain),
<a name="273"/>  273:               DirJID = &lt;&lt;&quot;vjud.&quot;,Domain/binary&gt;&gt;,
<a name="274"/>  274:               Fields = [{get_field_name(fn), get_FN_wildcard()}],
<a name="275"/>  275:               Res = escalus:send_and_wait(Client,
<a name="276"/>  276:                                           escalus_stanza:search_iq(DirJID,
<a name="277"/>  277:                                                                    escalus_stanza:search_fields(Fields))),
<a name="278"/>  278:               escalus:assert(is_iq_result, Res),
<a name="279"/>  279:               ItemTups = search_result_item_tuples(Res),
<a name="280"/>  280:               1 = length(ItemTups)
<a name="281"/>  281:       end).
<a name="282"/>  282: 
<a name="283"/>  283: <i>%%--------------------------------------------------------------------</i>
<a name="284"/>  284: <i>%% Helper functions</i>
<a name="285"/>  285: <i>%%--------------------------------------------------------------------</i>
<a name="286"/>  286: 
<a name="expected_search_results-2"/><a name="287"/>  287: <b>expected_search_results</b>(Key, Config) -&gt;
<a name="288"/>  288:     {_, ExpectedResults} =
<a name="289"/>  289:     lists:keyfind(expected_results, 1,
<a name="290"/>  290:                   escalus_config:get_config(search_data, Config)),
<a name="291"/>  291:     lists:keyfind(Key, 1, ExpectedResults).
<a name="292"/>  292: 
<a name="293"/>  293: <i>%%----------------------</i>
<a name="294"/>  294: <i>%% xmlel shortcuts</i>
<a name="stanza_get_vcard_field-2"/><a name="295"/>  295: <b>stanza_get_vcard_field</b>(Stanza, FieldName) -&gt;
<a name="296"/>  296:     VCard = ?EL(Stanza, &lt;&lt;&quot;vCard&quot;&gt;&gt;),
<a name="297"/>  297:     ?EL(VCard, FieldName).
<a name="298"/>  298: 
<a name="stanza_get_vcard_field_cdata-2"/><a name="299"/>  299: <b>stanza_get_vcard_field_cdata</b>(Stanza, FieldName) -&gt;
<a name="300"/>  300:     VCard = ?EL(Stanza, &lt;&lt;&quot;vCard&quot;&gt;&gt;),
<a name="301"/>  301:     ?EL_CD(VCard, FieldName).
<a name="302"/>  302: 
<a name="303"/>  303: <i>%%---------------------</i>
<a name="304"/>  304: <i>%% test helpers</i>
<a name="305"/>  305: 
<a name="306"/>  306: <i>%%</i>
<a name="307"/>  307: <i>%% -&gt; [{Type, Var, Label}]</i>
<a name="308"/>  308: <i>%%</i>
<a name="field_tuples-1"/><a name="309"/>  309: <b>field_tuples</b>([]) -&gt;
<a name="310"/>  310:     [];
<a name="311"/>  311: <b>field_tuples</b>([#xmlel{name = &lt;&lt;&quot;field&quot;&gt;&gt;,
<a name="312"/>  312:                      attrs=Attrs,
<a name="313"/>  313:                      children=_Children} = El| Rest]) -&gt;
<a name="314"/>  314:     {&lt;&lt;&quot;type&quot;&gt;&gt;,Type} = lists:keyfind(&lt;&lt;&quot;type&quot;&gt;&gt;, 1, Attrs),
<a name="315"/>  315:     {&lt;&lt;&quot;var&quot;&gt;&gt;,Var} = lists:keyfind(&lt;&lt;&quot;var&quot;&gt;&gt;, 1, Attrs),
<a name="316"/>  316:     {&lt;&lt;&quot;label&quot;&gt;&gt;,Label} = lists:keyfind(&lt;&lt;&quot;label&quot;&gt;&gt;, 1, Attrs),
<a name="317"/>  317:     case ?EL_CD(El, &lt;&lt;&quot;value&quot;&gt;&gt;) of
<a name="318"/>  318:         undefined -&gt;
<a name="319"/>  319:             [{Type, Var, Label}|field_tuples(Rest)];
<a name="320"/>  320:         ValCData -&gt;
<a name="321"/>  321:             [{Type, Var, Label, ValCData}|field_tuples(Rest)]
<a name="322"/>  322:     end;
<a name="323"/>  323: <b>field_tuples</b>([_SomeOtherEl|Rest]) -&gt;
<a name="324"/>  324:     field_tuples(Rest).
<a name="325"/>  325: 
<a name="326"/>  326: 
<a name="327"/>  327: <i>%%</i>
<a name="328"/>  328: <i>%%  -&gt; [{Type, Var, Label, ValueCData}]</i>
<a name="329"/>  329: <i>%%</i>
<a name="330"/>  330: <i>%% This is naiive and expensive LOL!</i>
<a name="item_field_tuples-2"/><a name="331"/>  331: <b>item_field_tuples</b>(_, []) -&gt;
<a name="332"/>  332:     [];
<a name="333"/>  333: <b>item_field_tuples</b>(ReportedFieldTups,
<a name="334"/>  334:                   [#xmlel{name = &lt;&lt;&quot;field&quot;&gt;&gt;,
<a name="335"/>  335:                           attrs=Attrs,
<a name="336"/>  336:                           children=_Children} = El| Rest]) -&gt;
<a name="337"/>  337:     {&lt;&lt;&quot;var&quot;&gt;&gt;,Var} = lists:keyfind(&lt;&lt;&quot;var&quot;&gt;&gt;, 1, Attrs),
<a name="338"/>  338:     {Type, Var, Label} = lists:keyfind(Var, 2, ReportedFieldTups),
<a name="339"/>  339:     [{Type, Var, Label, ?EL_CD(El, &lt;&lt;&quot;value&quot;&gt;&gt;)}
<a name="340"/>  340:      | item_field_tuples(ReportedFieldTups, Rest)];
<a name="341"/>  341: 
<a name="342"/>  342: <b>item_field_tuples</b>(ReportedFieldTups, [_SomeOtherEl|Rest]) -&gt;
<a name="343"/>  343:     item_field_tuples(ReportedFieldTups, Rest).
<a name="344"/>  344: 
<a name="345"/>  345: 
<a name="346"/>  346: <i>%%</i>
<a name="347"/>  347: <i>%% -&gt; [{JID, [ItemFieldTups]}]</i>
<a name="348"/>  348: <i>%%</i>
<a name="349"/>  349: <i>%% Finds the JID and maps fields to their labels and types</i>
<a name="350"/>  350: <i>%%</i>
<a name="item_tuples-2"/><a name="351"/>  351: <b>item_tuples</b>(_, []) -&gt;
<a name="352"/>  352:     [];
<a name="353"/>  353: <b>item_tuples</b>(ReportedFieldTups, [#xmlel{name = &lt;&lt;&quot;item&quot;&gt;&gt;,
<a name="354"/>  354:                                        children = Children} | Rest]) -&gt;
<a name="355"/>  355:     ItemFieldTups = item_field_tuples(ReportedFieldTups, Children),
<a name="356"/>  356:     {_,_,_,JID} = lists:keyfind(&lt;&lt;&quot;jid&quot;&gt;&gt;, 2, ItemFieldTups),
<a name="357"/>  357:     [{JID, ItemFieldTups}|item_tuples(ReportedFieldTups, Rest)];
<a name="358"/>  358: <b>item_tuples</b>(ReportedFieldTypes, [_SomeOtherChild | Rest]) -&gt;
<a name="359"/>  359:     item_tuples(ReportedFieldTypes, Rest).
<a name="360"/>  360: 
<a name="361"/>  361: 
<a name="362"/>  362: <i>%% This tests that at least the values in the ExpectedVCardTups are in the</i>
<a name="363"/>  363: <i>%% VCardUnderTest.</i>
<a name="364"/>  364: <i>%% Any extra values in the vcard are ignored by this function and should be</i>
<a name="365"/>  365: <i>%% checked or rejected elsewhere.</i>
<a name="366"/>  366: <i>%% crash means fail, return means success.</i>
<a name="check_vcard-2"/><a name="367"/>  367: <b>check_vcard</b>(ExpectedVCardTups, Stanza) -&gt;
<a name="368"/>  368:     escalus_pred:is_iq(&lt;&lt;&quot;result&quot;&gt;&gt;, Stanza),
<a name="369"/>  369:     VCardUnderTest = ?EL(Stanza, &lt;&lt;&quot;vCard&quot;&gt;&gt;),
<a name="370"/>  370:     check_xml_element(ExpectedVCardTups, VCardUnderTest).
<a name="371"/>  371: 
<a name="372"/>  372: 
<a name="check_xml_element-2"/><a name="373"/>  373: <b>check_xml_element</b>([], _ElUnderTest) -&gt;
<a name="374"/>  374:     ok;  %% just return true to be consistent with other clauses.
<a name="375"/>  375: <b>check_xml_element</b>([{ExpdFieldName, ExpdChildren}|Rest], ElUnderTest)
<a name="376"/>  376:   when is_list(ExpdChildren) -&gt;
<a name="377"/>  377:     check_xml_element(ExpdChildren, ?EL(ElUnderTest, ExpdFieldName)),
<a name="378"/>  378:     check_xml_element(Rest, ElUnderTest);
<a name="379"/>  379: <b>check_xml_element</b>([{ExpdFieldName, ExpdCData}|Rest], ElUnderTest) -&gt;
<a name="380"/>  380:     case ?EL_CD(ElUnderTest, ExpdFieldName) of
<a name="381"/>  381:         ExpdCData -&gt;
<a name="382"/>  382:             check_xml_element(Rest, ElUnderTest);
<a name="383"/>  383:         Else -&gt;
<a name="384"/>  384:             ct:fail(&quot;Expected ~p got ~p~n&quot;, [ExpdCData, Else])
<a name="385"/>  385:     end.
<a name="386"/>  386: 
<a name="387"/>  387: <i>%% Checks that the elements of two lists with matching keys are equal</i>
<a name="388"/>  388: <i>%% while the order of the elements does not matter.</i>
<a name="389"/>  389: <i>%% Returning means success. Crashing via ct:fail means failure.</i>
<a name="390"/>  390: <i>%% Prints the lists in the ct:fail Result term.</i>
<a name="list_unordered_key_match-3"/><a name="391"/>  391: <b>list_unordered_key_match</b>(Keypos, Expected, Actual) -&gt;
<a name="392"/>  392:     case length(Actual) of
<a name="393"/>  393:         ActualLength when ActualLength == length(Expected) -&gt;
<a name="394"/>  394:             list_unordered_key_match2(Keypos, Expected, Actual);
<a name="395"/>  395:         ActualLength -&gt;
<a name="396"/>  396:             ct:fail(&quot;Expected size ~p, actual size ~p~nExpected: ~p~nActual: ~p&quot;,
<a name="397"/>  397:                     [length(Expected), ActualLength, Expected, Actual])
<a name="398"/>  398:     end.
<a name="399"/>  399: 
<a name="list_unordered_key_match2-3"/><a name="400"/>  400: <b>list_unordered_key_match2</b>(_, [], _) -&gt;
<a name="401"/>  401:     ok;
<a name="402"/>  402: <b>list_unordered_key_match2</b>(Keypos, [ExpctdTup|Rest], ActualTuples) -&gt;
<a name="403"/>  403:     Key = element(Keypos, ExpctdTup),
<a name="404"/>  404:     ActualTup = lists:keyfind(Key, Keypos, ActualTuples),
<a name="405"/>  405:     case ActualTup of
<a name="406"/>  406:         ExpctdTup -&gt;
<a name="407"/>  407:             list_unordered_key_match2(Keypos, Rest, ActualTuples);
<a name="408"/>  408:         _ -&gt;
<a name="409"/>  409:             ct:fail(&quot;~nExpected ~p~nGot ~p&quot;, [ExpctdTup, ActualTup])
<a name="410"/>  410:     end.
<a name="411"/>  411: 
<a name="search_result_item_tuples-1"/><a name="412"/>  412: <b>search_result_item_tuples</b>(Stanza) -&gt;
<a name="413"/>  413:     Result = ?EL(Stanza, &lt;&lt;&quot;query&quot;&gt;&gt;),
<a name="414"/>  414:     XData = ?EL(Result, &lt;&lt;&quot;x&quot;&gt;&gt;),
<a name="415"/>  415:     #xmlel{ attrs = _XAttrs,
<a name="416"/>  416:             children = XChildren } = XData,
<a name="417"/>  417:     Reported = ?EL(XData, &lt;&lt;&quot;reported&quot;&gt;&gt;),
<a name="418"/>  418:     ReportedFieldTups = field_tuples(Reported#xmlel.children),
<a name="419"/>  419:     _ItemTups = item_tuples(ReportedFieldTups, XChildren).
<a name="420"/>  420: 
<a name="is_vcard_ldap-0"/><a name="421"/>  421: <b>is_vcard_ldap</b>()-&gt;
<a name="422"/>  422:     ldap==escalus_ejabberd:rpc(gen_mod,get_module_opt,[ct:get_config(ejabberd_domain), mod_vcard, backend, mnesia]).
<a name="423"/>  423: 
<a name="get_field_name-1"/><a name="424"/>  424: <b>get_field_name</b>(fn)-&gt;
<a name="425"/>  425:     case is_vcard_ldap() of
<a name="426"/>  426:         true -&gt; &lt;&lt;&quot;cn&quot;&gt;&gt;;
<a name="427"/>  427:         false -&gt; &lt;&lt;&quot;fn&quot;&gt;&gt;
<a name="428"/>  428:     end;
<a name="429"/>  429: <b>get_field_name</b>(user)-&gt;
<a name="430"/>  430:     case is_vcard_ldap() of
<a name="431"/>  431:         true -&gt; &lt;&lt;&quot;uid&quot;&gt;&gt;;
<a name="432"/>  432:         false -&gt; &lt;&lt;&quot;user&quot;&gt;&gt;
<a name="433"/>  433:     end.
<a name="434"/>  434: 
<a name="get_FN_wildcard-0"/><a name="435"/>  435: <b>get_FN_wildcard</b>() -&gt;
<a name="436"/>  436:     case is_vcard_ldap() of
<a name="437"/>  437:         true -&gt; &lt;&lt;&quot;*li*e&quot;&gt;&gt;;
<a name="438"/>  438:         false -&gt; &lt;&lt;&quot;old*&quot;&gt;&gt;
<a name="439"/>  439:     end.
<a name="get_FN-1"/><a name="440"/>  440: <b>get_FN</b>(Config) -&gt;
<a name="441"/>  441:     case is_vcard_ldap() of
<a name="442"/>  442:         true -&gt;
<a name="443"/>  443:             escalus_utils:jid_to_lower(escalus_users:get_username(Config, alice));
<a name="444"/>  444:         false -&gt;
<a name="445"/>  445:             &lt;&lt;&quot;Old Name&quot;&gt;&gt;
<a name="446"/>  446:     end.
<a name="447"/>  447: 
<a name="configure_ldap_vcards-1"/><a name="448"/>  448: <b>configure_ldap_vcards</b>(Config) -&gt;
<a name="449"/>  449:     Domain = escalus_config:get_config(ejabberd_domain, Config),
<a name="450"/>  450:     CurrentConfigs = escalus_ejabberd:rpc(gen_mod, loaded_modules_with_opts, [Domain]),
<a name="451"/>  451:     {mod_vcard, CurrentVcardConfig} = lists:keyfind(mod_vcard, 1, CurrentConfigs),
<a name="452"/>  452:     dynamic_modules:stop(Domain, mod_vcard),
<a name="453"/>  453:     Cfg = [{backend,ldap},
<a name="454"/>  454:            {ldap_filter,&quot;(objectClass=inetOrgPerson)&quot;},
<a name="455"/>  455:            {ldap_base,&quot;ou=Users,dc=esl,dc=com&quot;},
<a name="456"/>  456:            {ldap_search_fields, [{&quot;Full Name&quot;,&quot;cn&quot;},{&quot;User&quot;,&quot;uid&quot;}]},
<a name="457"/>  457:            {ldap_vcard_map,[{&quot;FN&quot;,[{&quot;%s&quot;,[&quot;cn&quot;]}]}]}],
<a name="458"/>  458:     dynamic_modules:start(Domain, mod_vcard, Cfg),
<a name="459"/>  459:     [{mod_vcard, CurrentVcardConfig} | Config].
<a name="460"/>  460: 
<a name="restore_ldap_vcards_config-1"/><a name="461"/>  461: <b>restore_ldap_vcards_config</b>(Config) -&gt;
<a name="462"/>  462:     OriginalConfig = ?config(mod_vcard, Config),
<a name="463"/>  463:     Domain = escalus_config:get_config(ejabberd_domain, Config),
<a name="464"/>  464:     dynamic_modules:stop(Domain, mod_vcard),
<a name="465"/>  465:     dynamic_modules:start(Domain, mod_vcard, OriginalConfig).
</pre>
</body>
</html>
