<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- autogenerated by 'erl2html2'. -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>/home/travis/build/esl/MongooseIM/test/ejabberd_tests/tests/bosh_SUITE.erl</title>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<pre>
<a name="1"/>    1: <i>%%==============================================================================</i>
<a name="2"/>    2: <i>%% Copyright 2012 Erlang Solutions Ltd.</i>
<a name="3"/>    3: <i>%%</i>
<a name="4"/>    4: <i>%% Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</i>
<a name="5"/>    5: <i>%% you may not use this file except in compliance with the License.</i>
<a name="6"/>    6: <i>%% You may obtain a copy of the License at</i>
<a name="7"/>    7: <i>%%</i>
<a name="8"/>    8: <i>%% http://www.apache.org/licenses/LICENSE-2.0</i>
<a name="9"/>    9: <i>%%</i>
<a name="10"/>   10: <i>%% Unless required by applicable law or agreed to in writing, software</i>
<a name="11"/>   11: <i>%% distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</i>
<a name="12"/>   12: <i>%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i>
<a name="13"/>   13: <i>%% See the License for the specific language governing permissions and</i>
<a name="14"/>   14: <i>%% limitations under the License.</i>
<a name="15"/>   15: <i>%%==============================================================================</i>
<a name="16"/>   16: 
<a name="17"/>   17: <b>-module</b>(bosh_SUITE).
<a name="18"/>   18: <b>-compile</b>(export_all).
<a name="19"/>   19: 
<a name="20"/>   20: <b>-include_lib</b>(&quot;escalus/include/escalus.hrl&quot;).
<a name="21"/>   21: <b>-include_lib</b>(&quot;common_test/include/ct.hrl&quot;).
<a name="22"/>   22: <b>-include_lib</b>(&quot;exml/include/exml.hrl&quot;).
<a name="23"/>   23: 
<a name="24"/>   24: <i>%%--------------------------------------------------------------------</i>
<a name="25"/>   25: <i>%% Suite configuration</i>
<a name="26"/>   26: <i>%%--------------------------------------------------------------------</i>
<a name="27"/>   27: 
<a name="28"/>   28: <b>-define</b>(INACTIVITY, 2). %% seconds
<a name="29"/>   29: <b>-define</b>(MAX_WAIT, 1). %% seconds
<a name="30"/>   30: <b>-define</b>(INVALID_RID_OFFSET, 999).
<a name="31"/>   31: 
<a name="all-0"/><a name="32"/>   32: <b>all</b>() -&gt;
<a name="33"/>   33:     [{group, essential},
<a name="34"/>   34: 
<a name="35"/>   35:      {group, chat},
<a name="36"/>   36: 
<a name="37"/>   37:      {group, time},
<a name="38"/>   38:      {group, acks},
<a name="39"/>   39: 
<a name="40"/>   40:      {group, essential_https},
<a name="41"/>   41:      {group, chat_https}].
<a name="42"/>   42: 
<a name="groups-0"/><a name="43"/>   43: <b>groups</b>() -&gt;
<a name="44"/>   44:     [{essential, [shuffle, {repeat_until_any_fail,10}], essential_test_cases()},
<a name="45"/>   45:      {essential_https, [shuffle, {repeat_until_any_fail,10}], essential_test_cases()},
<a name="46"/>   46:      {chat, [shuffle, {repeat_until_any_fail,10}], chat_test_cases()},
<a name="47"/>   47:      {chat_https, [shuffle, {repeat_until_any_fail,10}], chat_test_cases()},
<a name="48"/>   48:      {time, [shuffle, {repeat_until_any_fail,10}], time_test_cases()},
<a name="49"/>   49:      {acks, [shuffle, {repeat_until_any_fail,5}], acks_test_cases()}].
<a name="50"/>   50: 
<a name="suite-0"/><a name="51"/>   51: <b>suite</b>() -&gt;
<a name="52"/>   52:     escalus:suite().
<a name="53"/>   53: 
<a name="essential_test_cases-0"/><a name="54"/>   54: <b>essential_test_cases</b>() -&gt;
<a name="55"/>   55:     [create_and_terminate_session,
<a name="56"/>   56:      accept_higher_hold_value,
<a name="57"/>   57:      do_not_accept_0_hold_value,
<a name="58"/>   58:      options_request,
<a name="59"/>   59:      get_request,
<a name="60"/>   60:      post_empty_body,
<a name="61"/>   61:      put_request].
<a name="62"/>   62: 
<a name="chat_test_cases-0"/><a name="63"/>   63: <b>chat_test_cases</b>() -&gt;
<a name="64"/>   64:     [interleave_requests,
<a name="65"/>   65:      simple_chat,
<a name="66"/>   66:      cdata_escape_chat,
<a name="67"/>   67:      escape_attr_chat,
<a name="68"/>   68:      cant_send_invalid_rid,
<a name="69"/>   69:      multiple_stanzas,
<a name="70"/>   70:      namespace,
<a name="71"/>   71:      stream_error].
<a name="72"/>   72: 
<a name="time_test_cases-0"/><a name="73"/>   73: <b>time_test_cases</b>() -&gt;
<a name="74"/>   74:     [disconnect_inactive,
<a name="75"/>   75:      connection_interrupted,
<a name="76"/>   76:      interrupt_long_poll_is_activity,
<a name="77"/>   77:      reply_on_pause,
<a name="78"/>   78:      cant_pause_for_too_long,
<a name="79"/>   79:      pause_request_is_activity,
<a name="80"/>   80:      reply_in_time
<a name="81"/>   81:     ].
<a name="82"/>   82: 
<a name="acks_test_cases-0"/><a name="83"/>   83: <b>acks_test_cases</b>() -&gt;
<a name="84"/>   84:     [server_acks,
<a name="85"/>   85:      force_report,
<a name="86"/>   86:      force_retransmission,
<a name="87"/>   87:      force_cache_trimming].
<a name="88"/>   88: 
<a name="89"/>   89: <i>%%--------------------------------------------------------------------</i>
<a name="90"/>   90: <i>%% Init &amp; teardown</i>
<a name="91"/>   91: <i>%%--------------------------------------------------------------------</i>
<a name="92"/>   92: 
<a name="init_per_suite-1"/><a name="93"/>   93: <b>init_per_suite</b>(Config) -&gt;
<a name="94"/>   94:     escalus:init_per_suite([{escalus_user_db, {module, escalus_ejabberd}} | Config]).
<a name="95"/>   95: 
<a name="end_per_suite-1"/><a name="96"/>   96: <b>end_per_suite</b>(Config) -&gt;
<a name="97"/>   97:     escalus:end_per_suite(Config).
<a name="98"/>   98: 
<a name="99"/>   99: 
<a name="init_per_group-2"/><a name="100"/>  100: <b>init_per_group</b>(essential, Config) -&gt;
<a name="101"/>  101:     [{user, carol} | Config];
<a name="102"/>  102: <b>init_per_group</b>(essential_https, Config) -&gt;
<a name="103"/>  103:     [{user, carol_s} | Config];
<a name="104"/>  104: <b>init_per_group</b>(chat_https, Config) -&gt;
<a name="105"/>  105:     Config1 = escalus_users:create_users(Config, {by_name, [carol, carol_s, geralt, alice]}),
<a name="106"/>  106:     [{user, carol_s} | Config1];
<a name="107"/>  107: <b>init_per_group</b>(_GroupName, Config) -&gt;
<a name="108"/>  108:     Config1 = escalus_users:create_users(Config, {by_name, [carol, carol_s, geralt, alice]}),
<a name="109"/>  109:     [{user, carol} | Config1].
<a name="110"/>  110: 
<a name="end_per_group-2"/><a name="111"/>  111: <b>end_per_group</b>(GroupName, Config)
<a name="112"/>  112:     when GroupName =:= essential; GroupName =:= essential_https -&gt;
<a name="113"/>  113:     Config;
<a name="114"/>  114: <b>end_per_group</b>(_GroupName, Config) -&gt;
<a name="115"/>  115:     R = escalus_users:delete_users(Config, {by_name, [carol, carol_s, geralt, alice]}),
<a name="116"/>  116:     mongoose_helper:clear_last_activity(Config, carol),
<a name="117"/>  117:     R.
<a name="118"/>  118: 
<a name="119"/>  119: 
<a name="init_per_testcase-2"/><a name="120"/>  120: <b>init_per_testcase</b>(disconnect_inactive = CaseName, Config) -&gt;
<a name="121"/>  121:     NewConfig = escalus_ejabberd:setup_option(inactivity(), Config),
<a name="122"/>  122:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="123"/>  123: <b>init_per_testcase</b>(connection_interrupted = CaseName, Config) -&gt;
<a name="124"/>  124:     NewConfig = escalus_ejabberd:setup_option(inactivity(), Config),
<a name="125"/>  125:     NewerConfig = escalus_ejabberd:setup_option(max_wait(), NewConfig),
<a name="126"/>  126:     escalus:init_per_testcase(CaseName, NewerConfig);
<a name="127"/>  127: <b>init_per_testcase</b>(interrupt_long_poll_is_activity = CaseName, Config) -&gt;
<a name="128"/>  128:     InactConfig = escalus_ejabberd:setup_option(inactivity(), Config),
<a name="129"/>  129:     NewConfig = escalus_users:update_userspec(InactConfig, carol, bosh_wait, 10),
<a name="130"/>  130:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="131"/>  131: <b>init_per_testcase</b>(reply_on_pause = CaseName, Config) -&gt;
<a name="132"/>  132:     NewConfig = escalus_ejabberd:setup_option(inactivity(), Config),
<a name="133"/>  133:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="134"/>  134: <b>init_per_testcase</b>(pause_request_is_activity = CaseName, Config) -&gt;
<a name="135"/>  135:     NewConfig = escalus_ejabberd:setup_option(inactivity(5), Config),
<a name="136"/>  136:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="137"/>  137: <b>init_per_testcase</b>(reply_in_time = CaseName, Config) -&gt;
<a name="138"/>  138:     InactConfig = escalus_ejabberd:setup_option(inactivity(10), Config),
<a name="139"/>  139:     NewConfig = escalus_users:update_userspec(InactConfig, carol, bosh_wait, 3),
<a name="140"/>  140:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="141"/>  141: <b>init_per_testcase</b>(server_acks = CaseName, Config) -&gt;
<a name="142"/>  142:     NewConfig = escalus_ejabberd:setup_option(server_acks_opt(), Config),
<a name="143"/>  143:     escalus:init_per_testcase(CaseName, NewConfig);
<a name="144"/>  144: <b>init_per_testcase</b>(CaseName, Config) -&gt;
<a name="145"/>  145:     escalus:init_per_testcase(CaseName, Config).
<a name="146"/>  146: 
<a name="end_per_testcase-2"/><a name="147"/>  147: <b>end_per_testcase</b>(disconnect_inactive = CaseName, Config) -&gt;
<a name="148"/>  148:     NewConfig = escalus_ejabberd:reset_option(inactivity(), Config),
<a name="149"/>  149:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="150"/>  150: <b>end_per_testcase</b>(connection_interrupted = CaseName, Config) -&gt;
<a name="151"/>  151:     NewConfig = escalus_ejabberd:reset_option(max_wait(), Config),
<a name="152"/>  152:     NewerConfig = escalus_ejabberd:reset_option(inactivity(), NewConfig),
<a name="153"/>  153:     escalus:end_per_testcase(CaseName, NewerConfig);
<a name="154"/>  154: <b>end_per_testcase</b>(interrupt_long_poll_is_activity = CaseName, Config) -&gt;
<a name="155"/>  155:     NewConfig = escalus_ejabberd:reset_option(inactivity(), Config),
<a name="156"/>  156:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="157"/>  157: <b>end_per_testcase</b>(reply_on_pause = CaseName, Config) -&gt;
<a name="158"/>  158:     NewConfig = escalus_ejabberd:reset_option(inactivity(), Config),
<a name="159"/>  159:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="160"/>  160: <b>end_per_testcase</b>(pause_request_is_activity = CaseName, Config) -&gt;
<a name="161"/>  161:     NewConfig = escalus_ejabberd:reset_option(inactivity(), Config),
<a name="162"/>  162:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="163"/>  163: <b>end_per_testcase</b>(reply_in_time = CaseName, Config) -&gt;
<a name="164"/>  164:     NewConfig = escalus_ejabberd:reset_option(inactivity(), Config),
<a name="165"/>  165:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="166"/>  166: <b>end_per_testcase</b>(server_acks = CaseName, Config) -&gt;
<a name="167"/>  167:     NewConfig = escalus_ejabberd:reset_option(server_acks_opt(), Config),
<a name="168"/>  168:     escalus:end_per_testcase(CaseName, NewConfig);
<a name="169"/>  169: <b>end_per_testcase</b>(CaseName, Config) -&gt;
<a name="170"/>  170:     escalus:end_per_testcase(CaseName, Config).
<a name="171"/>  171: 
<a name="172"/>  172: <i>%%--------------------------------------------------------------------</i>
<a name="173"/>  173: <i>%% Tests</i>
<a name="174"/>  174: <i>%%--------------------------------------------------------------------</i>
<a name="175"/>  175: 
<a name="create_and_terminate_session-1"/><a name="176"/>  176: <b>create_and_terminate_session</b>(Config) -&gt;
<a name="177"/>  177:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="178"/>  178:     CarolSpec = proplists:get_value(?config(user, Config), NamedSpecs),
<a name="179"/>  179:     {ok, Conn} = escalus_bosh:connect(CarolSpec),
<a name="180"/>  180: 
<a name="181"/>  181:     %% Assert there are no BOSH sessions on the server.
<a name="182"/>  182:     0 = length(get_bosh_sessions()),
<a name="183"/>  183: 
<a name="184"/>  184:     Domain = escalus_config:get_config(ejabberd_domain, Config),
<a name="185"/>  185:     Body = escalus_bosh:session_creation_body(get_bosh_rid(Conn), Domain),
<a name="186"/>  186:     ok = escalus_bosh:send_raw(Conn, Body),
<a name="187"/>  187:     escalus_connection:get_stanza(Conn, session_creation_response),
<a name="188"/>  188: 
<a name="189"/>  189:     %% Assert that a BOSH session was created.
<a name="190"/>  190:     1 = length(get_bosh_sessions()),
<a name="191"/>  191: 
<a name="192"/>  192:     Sid = get_bosh_sid(Conn),
<a name="193"/>  193:     Terminate = escalus_bosh:session_termination_body(get_bosh_rid(Conn), Sid),
<a name="194"/>  194:     ok = escalus_bosh:send_raw(Conn, Terminate),
<a name="195"/>  195: 
<a name="196"/>  196:     timer:sleep(100),
<a name="197"/>  197:     %% Assert the session was terminated.
<a name="198"/>  198:     0 = length(get_bosh_sessions()).
<a name="199"/>  199: 
<a name="accept_higher_hold_value-1"/><a name="200"/>  200: <b>accept_higher_hold_value</b>(Config) -&gt;
<a name="201"/>  201:     #xmlel{attrs = RespAttrs} = send_specific_hold(Config, &lt;&lt;&quot;2&quot;&gt;&gt;),
<a name="202"/>  202:     {&lt;&lt;&quot;hold&quot;&gt;&gt;, &lt;&lt;&quot;1&quot;&gt;&gt;} = lists:keyfind(&lt;&lt;&quot;hold&quot;&gt;&gt;, 1, RespAttrs).
<a name="203"/>  203: 
<a name="do_not_accept_0_hold_value-1"/><a name="204"/>  204: <b>do_not_accept_0_hold_value</b>(Config) -&gt;
<a name="205"/>  205:     #xmlel{attrs = RespAttrs} = send_specific_hold(Config, &lt;&lt;&quot;0&quot;&gt;&gt;),
<a name="206"/>  206:     {&lt;&lt;&quot;type&quot;&gt;&gt;, &lt;&lt;&quot;terminate&quot;&gt;&gt;} = lists:keyfind(&lt;&lt;&quot;type&quot;&gt;&gt;, 1, RespAttrs).
<a name="207"/>  207: 
<a name="208"/>  208: 
<a name="send_specific_hold-2"/><a name="209"/>  209: <b>send_specific_hold</b>(Config, HoldValue) -&gt;
<a name="210"/>  210:     {Server, Path, Client} = get_fusco_connection(Config),
<a name="211"/>  211: 
<a name="212"/>  212:     Rid = random:uniform(1000000),
<a name="213"/>  213:     Body0 = escalus_bosh:session_creation_body(2, &lt;&lt;&quot;1.0&quot;&gt;&gt;, &lt;&lt;&quot;en&quot;&gt;&gt;, Rid, Server, nil),
<a name="214"/>  214:     #xmlel{attrs = Attrs0} = Body0,
<a name="215"/>  215:     Attrs = lists:keyreplace(&lt;&lt;&quot;hold&quot;&gt;&gt;, 1, Attrs0, {&lt;&lt;&quot;hold&quot;&gt;&gt;, HoldValue}),
<a name="216"/>  216:     Body = Body0#xmlel{attrs = Attrs},
<a name="217"/>  217: 
<a name="218"/>  218:     Result = fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, exml:to_iolist(Body)),
<a name="219"/>  219:     {{&lt;&lt;&quot;200&quot;&gt;&gt;,&lt;&lt;&quot;OK&quot;&gt;&gt;}, _Headers, RespBody, _, _} = Result,
<a name="220"/>  220: 
<a name="221"/>  221:     {ok, #xmlel{attrs = RespAttrs} = Resp} = exml:parse(RespBody),
<a name="222"/>  222:     case lists:keyfind(&lt;&lt;&quot;sid&quot;&gt;&gt;, 1, RespAttrs) of
<a name="223"/>  223:         {&lt;&lt;&quot;sid&quot;&gt;&gt;, SID} -&gt;
<a name="224"/>  224:             TerminateBody = escalus_bosh:session_termination_body(Rid + 1, SID),
<a name="225"/>  225:             fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, exml:to_iolist(TerminateBody));
<a name="226"/>  226:         _ -&gt;
<a name="227"/>  227:             skip
<a name="228"/>  228:     end,
<a name="229"/>  229:     fusco_cp:stop(Client),
<a name="230"/>  230:     Resp.
<a name="231"/>  231: 
<a name="fusco_request-4"/><a name="232"/>  232: <b>fusco_request</b>(Client, Method, Path, Body) -&gt;
<a name="233"/>  233:     fusco_request(Client, Method, Path, Body, []).
<a name="234"/>  234: 
<a name="fusco_request-5"/><a name="235"/>  235: <b>fusco_request</b>(Client, Method, Path, Body, HeadersIn) -&gt;
<a name="236"/>  236:     Headers = [{&lt;&lt;&quot;Content-Type&quot;&gt;&gt;, &lt;&lt;&quot;text/xml; charset=utf-8&quot;&gt;&gt;} | HeadersIn],
<a name="237"/>  237:     {ok, Result} = fusco_cp:request(Client, Path, Method, Headers, Body, 2, 5000),
<a name="238"/>  238:     Result.
<a name="239"/>  239: 
<a name="240"/>  240: 
<a name="options_request-1"/><a name="241"/>  241: <b>options_request</b>(Config) -&gt;
<a name="242"/>  242:     {Server, Path, Client} = get_fusco_connection(Config),
<a name="243"/>  243:     Result = fusco_request(Client, &lt;&lt;&quot;OPTIONS&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;, [{&lt;&lt;&quot;Origin&quot;&gt;&gt;, Server}]),
<a name="244"/>  244:     fusco_cp:stop(Client),
<a name="245"/>  245:     {{&lt;&lt;&quot;200&quot;&gt;&gt;, &lt;&lt;&quot;OK&quot;&gt;&gt;}, Headers, &lt;&lt;&gt;&gt;, _, _} = Result,
<a name="246"/>  246:     &lt;&lt;&quot;1728000&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-max-age&quot;&gt;&gt;, Headers),
<a name="247"/>  247:     &lt;&lt;&quot;Content-Type&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-allow-headers&quot;&gt;&gt;, Headers),
<a name="248"/>  248:     &lt;&lt;&quot;POST, OPTIONS, GET&quot;&gt;&gt; = proplists:get_value(&lt;&lt;&quot;access-control-allow-methods&quot;&gt;&gt;, Headers),
<a name="249"/>  249:     Server = proplists:get_value(&lt;&lt;&quot;access-control-allow-origin&quot;&gt;&gt;, Headers).
<a name="250"/>  250: 
<a name="get_request-1"/><a name="251"/>  251: <b>get_request</b>(Config) -&gt;
<a name="252"/>  252:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="253"/>  253:     Result = fusco_request(Client, &lt;&lt;&quot;GET&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;),
<a name="254"/>  254:     fusco_cp:stop(Client),
<a name="255"/>  255:     {{&lt;&lt;&quot;200&quot;&gt;&gt;,&lt;&lt;&quot;OK&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="256"/>  256: 
<a name="put_request-1"/><a name="257"/>  257: <b>put_request</b>(Config) -&gt;
<a name="258"/>  258:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="259"/>  259:     Result = fusco_request(Client, &lt;&lt;&quot;PUT&quot;&gt;&gt;, Path, &lt;&lt;&quot;not allowed body&quot;&gt;&gt;),
<a name="260"/>  260:     fusco_cp:stop(Client),
<a name="261"/>  261:     {{&lt;&lt;&quot;405&quot;&gt;&gt;,&lt;&lt;&quot;Method Not Allowed&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="262"/>  262: 
<a name="post_empty_body-1"/><a name="263"/>  263: <b>post_empty_body</b>(Config) -&gt;
<a name="264"/>  264:     {_Server, Path, Client} = get_fusco_connection(Config),
<a name="265"/>  265:     Result = fusco_request(Client, &lt;&lt;&quot;POST&quot;&gt;&gt;, Path, &lt;&lt;&gt;&gt;),
<a name="266"/>  266:     fusco_cp:stop(Client),
<a name="267"/>  267:     {{&lt;&lt;&quot;400&quot;&gt;&gt;,&lt;&lt;&quot;Bad Request&quot;&gt;&gt;}, _, _, _, _} = Result.
<a name="268"/>  268: 
<a name="get_fusco_connection-1"/><a name="269"/>  269: <b>get_fusco_connection</b>(Config) -&gt;
<a name="270"/>  270:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="271"/>  271:     CarolSpec = proplists:get_value(?config(user, Config), NamedSpecs),
<a name="272"/>  272:     Server = proplists:get_value(server, CarolSpec),
<a name="273"/>  273:     Path = proplists:get_value(path, CarolSpec),
<a name="274"/>  274:     Port = proplists:get_value(port, CarolSpec),
<a name="275"/>  275:     UseSSL = proplists:get_value(ssl, CarolSpec, false),
<a name="276"/>  276:     {ok, Client} = fusco_cp:start_link({binary_to_list(Server), Port, UseSSL}, [], 1),
<a name="277"/>  277:     {Server, Path, Client}.
<a name="278"/>  278: 
<a name="stream_error-1"/><a name="279"/>  279: <b>stream_error</b>(Config) -&gt;
<a name="280"/>  280:     escalus:story(
<a name="281"/>  281:       Config, [{?config(user, Config), 1}],
<a name="282"/>  282:       fun(Carol) -&gt;
<a name="283"/>  283:               %% Send a stanza with invalid 'from'
<a name="284"/>  284:               %% attribute to trigger a stream error from
<a name="285"/>  285:               %% the server.
<a name="286"/>  286:               BadMessage = escalus_stanza:chat(
<a name="287"/>  287:                              &lt;&lt;&quot;not_carol@localhost&quot;&gt;&gt;,
<a name="288"/>  288:                              &lt;&lt;&quot;geralt@localhost&quot;&gt;&gt;,
<a name="289"/>  289:                              &lt;&lt;&quot;I am not Carol&quot;&gt;&gt;),
<a name="290"/>  290:               escalus_client:send(Carol, BadMessage),
<a name="291"/>  291:               escalus:assert(is_stream_error, [&lt;&lt;&quot;invalid-from&quot;&gt;&gt;, &lt;&lt;&gt;&gt;],
<a name="292"/>  292:                              escalus_client:wait_for_stanza(Carol)),
<a name="293"/>  293:               %% connection should be closed, let's wait
<a name="294"/>  294:               true = wait_for_close(Carol, 10)
<a name="295"/>  295:       end).
<a name="296"/>  296: 
<a name="interleave_requests-1"/><a name="297"/>  297: <b>interleave_requests</b>(Config) -&gt;
<a name="298"/>  298:     escalus:story(Config, [{geralt, 1}], fun(Geralt) -&gt;
<a name="299"/>  299: 
<a name="300"/>  300:         Carol = start_client(Config, ?config(user, Config), &lt;&lt;&quot;bosh&quot;&gt;&gt;),
<a name="301"/>  301:         Rid = get_bosh_rid(Carol),
<a name="302"/>  302:         Sid = get_bosh_sid(Carol),
<a name="303"/>  303: 
<a name="304"/>  304:         Empty2 = escalus_bosh:empty_body(Rid + 1, Sid),
<a name="305"/>  305:         Chat2 = Empty2#xmlel{
<a name="306"/>  306:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd!&quot;&gt;&gt;)]},
<a name="307"/>  307:         escalus_bosh:send_raw(Carol, Chat2),
<a name="308"/>  308: 
<a name="309"/>  309:         Empty1 = escalus_bosh:empty_body(Rid, Sid),
<a name="310"/>  310:         Chat1 = Empty1#xmlel{
<a name="311"/>  311:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st!&quot;&gt;&gt;)]},
<a name="312"/>  312:         escalus_bosh:send_raw(Carol, Chat1),
<a name="313"/>  313: 
<a name="314"/>  314:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st!&quot;&gt;&gt;],
<a name="315"/>  315:                        escalus_client:wait_for_stanza(Geralt)),
<a name="316"/>  316:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd!&quot;&gt;&gt;],
<a name="317"/>  317:                        escalus_client:wait_for_stanza(Geralt))
<a name="318"/>  318: 
<a name="319"/>  319:     end).
<a name="320"/>  320: 
<a name="321"/>  321: 
<a name="simple_chat-1"/><a name="322"/>  322: <b>simple_chat</b>(Config) -&gt;
<a name="323"/>  323:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="324"/>  324: 
<a name="325"/>  325:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hi!&quot;&gt;&gt;)),
<a name="326"/>  326:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hi!&quot;&gt;&gt;],
<a name="327"/>  327:                        escalus_client:wait_for_stanza(Geralt)),
<a name="328"/>  328: 
<a name="329"/>  329:         escalus_client:send(Geralt,
<a name="330"/>  330:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="331"/>  331:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="332"/>  332:                        escalus_client:wait_for_stanza(Carol))
<a name="333"/>  333: 
<a name="334"/>  334:         end).
<a name="335"/>  335: 
<a name="cdata_escape_chat-1"/><a name="336"/>  336: <b>cdata_escape_chat</b>(Config) -&gt;
<a name="337"/>  337:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="338"/>  338:         special_chars_helper:check_cdata_from_to(Carol, Carol, &lt;&lt;&quot;Hi! &amp; &lt; &gt; &quot;&gt;&gt;),
<a name="339"/>  339:         special_chars_helper:check_cdata_from_to(Geralt, Carol, &lt;&lt;&quot;Hi there! &amp; &lt; &gt; &quot;&gt;&gt;)
<a name="340"/>  340: 
<a name="341"/>  341:     end).
<a name="342"/>  342: 
<a name="escape_attr_chat-1"/><a name="343"/>  343: <b>escape_attr_chat</b>(Config) -&gt;
<a name="344"/>  344:     escalus:story(Config, [{?config(user, Config), 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="345"/>  345:         special_chars_helper:check_attr_from_to(Carol, Geralt),
<a name="346"/>  346:         special_chars_helper:check_attr_from_to(Geralt, Carol)
<a name="347"/>  347:     end).
<a name="348"/>  348: 
<a name="cant_send_invalid_rid-1"/><a name="349"/>  349: <b>cant_send_invalid_rid</b>(Config) -&gt;
<a name="350"/>  350:     escalus:story(Config, [{?config(user, Config), 1}], fun(Carol) -&gt;
<a name="351"/>  351:         %% ct:pal(&quot;This test will leave invalid rid, session not found&quot;
<a name="352"/>  352:         %%        &quot; errors in the server log~n&quot;),
<a name="353"/>  353: 
<a name="354"/>  354:         %% NOTICE 1
<a name="355"/>  355:         %% This test will provoke the server to log the following message:
<a name="356"/>  356:         %%
<a name="357"/>  357:         %% mod_bosh_socket:handle_stream_event:401
<a name="358"/>  358:         %% invalid rid XXX, expected YYY, difference ?INVALID_RID_OFFSET:
<a name="359"/>  359: 
<a name="360"/>  360:         %% NOTICE 2
<a name="361"/>  361:         %% Escalus will try to close the session under test when the story
<a name="362"/>  362:         %% completes. This will leave the following message in the log:
<a name="363"/>  363:         %%
<a name="364"/>  364:         %% mod_bosh:forward_body:265 session not found!
<a name="365"/>  365: 
<a name="366"/>  366:         InvalidRid = get_bosh_rid(Carol) + ?INVALID_RID_OFFSET,
<a name="367"/>  367:         Sid = get_bosh_sid(Carol),
<a name="368"/>  368:         Empty = escalus_bosh:empty_body(InvalidRid, Sid),
<a name="369"/>  369:         escalus_bosh:send_raw(Carol, Empty),
<a name="370"/>  370: 
<a name="371"/>  371:         escalus:assert(is_stream_end, escalus:wait_for_stanza(Carol)),
<a name="372"/>  372:         true = wait_for_close(Carol, 10),
<a name="373"/>  373:         true = wait_for_session_close(Sid, 10)
<a name="374"/>  374:         end).
<a name="375"/>  375: 
<a name="multiple_stanzas-1"/><a name="376"/>  376: <b>multiple_stanzas</b>(Config) -&gt;
<a name="377"/>  377:     escalus:story(Config, [{?config(user, Config), 1},{geralt, 1},{alice, 1}],
<a name="378"/>  378:                   fun(Carol, Geralt, Alice) -&gt;
<a name="379"/>  379:                 %% send a multiple stanza
<a name="380"/>  380:                 Server = escalus_client:server(Carol),
<a name="381"/>  381:                 Stanza1 = escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="382"/>  382:                 Stanza2 = escalus_stanza:chat_to(Alice, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="383"/>  383:                 Stanza3 = escalus_stanza:service_discovery(Server),
<a name="384"/>  384: 
<a name="385"/>  385:                 RID = escalus_bosh:get_rid(Carol),
<a name="386"/>  386:                 SID = escalus_bosh:get_sid(Carol),
<a name="387"/>  387:                 Body = escalus_bosh:empty_body(RID, SID),
<a name="388"/>  388:                 Stanza = Body#xmlel{children=[Stanza1,Stanza2,Stanza1,Stanza3]},
<a name="389"/>  389:                 escalus_bosh:send_raw(Carol, Stanza),
<a name="390"/>  390: 
<a name="391"/>  391:                 %% check whether each of stanzas has been processed correctly
<a name="392"/>  392:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="393"/>  393:                                escalus_client:wait_for_stanza(Geralt)),
<a name="394"/>  394:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="395"/>  395:                                escalus_client:wait_for_stanza(Alice)),
<a name="396"/>  396:                 escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello&quot;&gt;&gt;],
<a name="397"/>  397:                                escalus_client:wait_for_stanza(Geralt)),
<a name="398"/>  398:                 escalus:assert(is_iq_result, escalus:wait_for_stanza(Carol))
<a name="399"/>  399:         end).
<a name="400"/>  400: 
<a name="namespace-1"/><a name="401"/>  401: <b>namespace</b>(Config) -&gt;
<a name="402"/>  402:     escalus:story(Config, [{?config(user, Config), 1},{geralt, 1}],
<a name="403"/>  403:         fun(Carol, Geralt) -&gt;
<a name="404"/>  404:             %% send a multiple stanza
<a name="405"/>  405:             Server = escalus_client:server(Carol),
<a name="406"/>  406: 
<a name="407"/>  407:             Stanza1 = escalus_stanza:service_discovery(Server),
<a name="408"/>  408:             Stanza2 = escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello&quot;&gt;&gt;),
<a name="409"/>  409:             Stanza3 = escalus_stanza:presence_direct(Carol, &lt;&lt;&quot;available&quot;&gt;&gt;),
<a name="410"/>  410: 
<a name="411"/>  411:             RID = escalus_bosh:get_rid(Carol),
<a name="412"/>  412:             SID = escalus_bosh:get_sid(Carol),
<a name="413"/>  413:             Body = escalus_bosh:empty_body(RID, SID),
<a name="414"/>  414:             Stanza = Body#xmlel{children=[Stanza1]},
<a name="415"/>  415:             escalus_bosh:send_raw(Carol, Stanza),
<a name="416"/>  416: 
<a name="417"/>  417:             IQResp = escalus:wait_for_stanza(Carol),
<a name="418"/>  418: 
<a name="419"/>  419:             escalus:assert(is_iq, [&lt;&lt;&quot;result&quot;&gt;&gt;], IQResp),
<a name="420"/>  420:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], IQResp),
<a name="421"/>  421: 
<a name="422"/>  422:             escalus_client:send(Geralt, Stanza2),
<a name="423"/>  423:             escalus_client:send(Geralt, Stanza3),
<a name="424"/>  424: 
<a name="425"/>  425:             Message = escalus:wait_for_stanza(Carol),
<a name="426"/>  426:             escalus:assert(is_chat_message, Message),
<a name="427"/>  427:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], Message),
<a name="428"/>  428: 
<a name="429"/>  429:             Presence  = escalus:wait_for_stanza(Carol),
<a name="430"/>  430:             escalus:assert(is_presence, Presence),
<a name="431"/>  431:             escalus:assert(has_ns, [&lt;&lt;&quot;jabber:client&quot;&gt;&gt;], Presence)
<a name="432"/>  432:         end).
<a name="433"/>  433: 
<a name="disconnect_inactive-1"/><a name="434"/>  434: <b>disconnect_inactive</b>(Config) -&gt;
<a name="435"/>  435:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="436"/>  436: 
<a name="437"/>  437:         %% Sanity check - there should be one BOSH session belonging
<a name="438"/>  438:         %% to Carol.
<a name="439"/>  439:         1 = length(get_bosh_sessions()),
<a name="440"/>  440: 
<a name="441"/>  441:         %% Don't send new long-polling requests waiting for server push.
<a name="442"/>  442:         set_keepalive(Carol, false),
<a name="443"/>  443: 
<a name="444"/>  444:         %% Make Carol receive using the last remaining connection.
<a name="445"/>  445:         escalus_client:send(Geralt,
<a name="446"/>  446:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="447"/>  447: 
<a name="448"/>  448:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="449"/>  449:                        escalus_client:wait_for_stanza(Carol)),
<a name="450"/>  450: 
<a name="451"/>  451:         Sid = get_bosh_sid(Carol),
<a name="452"/>  452:         %% Ensure all connections for Carol have been closed.
<a name="453"/>  453:         {_, Sid, CarolSessionPid} = get_bosh_session(Sid),
<a name="454"/>  454:         [] = get_handlers(CarolSessionPid),
<a name="455"/>  455: 
<a name="456"/>  456:         %% Wait for disconnection because of inactivity timeout.
<a name="457"/>  457:         timer:sleep(2 * timer:seconds(?INACTIVITY)),
<a name="458"/>  458: 
<a name="459"/>  459:         %% Assert Carol has been disconnected due to inactivity.
<a name="460"/>  460:         false = is_sesssion_alive(Sid),
<a name="461"/>  461: 
<a name="462"/>  462:         %% We don't need to close the session in escalus_bosh:stop/1
<a name="463"/>  463:         mark_as_terminated(Carol)
<a name="464"/>  464: 
<a name="465"/>  465:         end).
<a name="466"/>  466: 
<a name="connection_interrupted-1"/><a name="467"/>  467: <b>connection_interrupted</b>(Config) -&gt;
<a name="468"/>  468:     escalus:story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="469"/>  469: 
<a name="470"/>  470:         %% Sanity check - there should be one BOSH session belonging
<a name="471"/>  471:         %% to Carol.
<a name="472"/>  472:         1 = length(get_bosh_sessions()),
<a name="473"/>  473: 
<a name="474"/>  474:         %% Turn off Escalus auto-reply, so that inactivity is triggered.
<a name="475"/>  475:         set_keepalive(Carol, false),
<a name="476"/>  476: 
<a name="477"/>  477:         Sid = get_bosh_sid(Carol),
<a name="478"/>  478: 
<a name="479"/>  479:         %% Terminate the connection, but don't notify the server.
<a name="480"/>  480:         escalus_connection:kill(Carol),
<a name="481"/>  481: 
<a name="482"/>  482:         %% Assert Carol has not been disconnected yet.
<a name="483"/>  483:         timer:sleep(100),
<a name="484"/>  484:         true = is_sesssion_alive(Sid),
<a name="485"/>  485: 
<a name="486"/>  486:         %% Wait for disconnection because of inactivity timeout.
<a name="487"/>  487:         %% Keep in mind this only works due to the max_wait also being lowered.
<a name="488"/>  488:         %% In other words, wait timeout must happen, so that there are
<a name="489"/>  489:         %% no requests held by the server for inactivity to cause disconnection.
<a name="490"/>  490:         timer:sleep(2 * timer:seconds(?INACTIVITY)),
<a name="491"/>  491: 
<a name="492"/>  492:         %% Assert Carol has been disconnected due to inactivity.
<a name="493"/>  493:         false = is_sesssion_alive(Sid)
<a name="494"/>  494: 
<a name="495"/>  495:         end).
<a name="496"/>  496: 
<a name="497"/>  497: <i>%% Ensure that a new request replacing an existing long-poll does not start the</i>
<a name="498"/>  498: <i>%% inactivity timer.</i>
<a name="interrupt_long_poll_is_activity-1"/><a name="499"/>  499: <b>interrupt_long_poll_is_activity</b>(Config) -&gt;
<a name="500"/>  500:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="501"/>  501: 
<a name="502"/>  502:         %% Sanity check - there should be one BOSH session belonging
<a name="503"/>  503:         %% to Carol and one handler for Carol.
<a name="504"/>  504:         Sid = get_bosh_sid(Carol),
<a name="505"/>  505:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="506"/>  506:         1 = wait_for_handler(CarolSessionPid),
<a name="507"/>  507: 
<a name="508"/>  508:         %% Send a message.  A new connection should be established, and
<a name="509"/>  509:         %% the existing long-poll connection should be closed.
<a name="510"/>  510:         escalus_client:send(Carol,
<a name="511"/>  511:                             escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="512"/>  512: 
<a name="513"/>  513:         %% Wait until after the inactivity timeout (which should be less than
<a name="514"/>  514:         %% the BOSH wait timeout).
<a name="515"/>  515:         timer:sleep(2 * timer:seconds(?INACTIVITY)),
<a name="516"/>  516: 
<a name="517"/>  517:         %% No disconnection should have occurred.
<a name="518"/>  518:         escalus_assert:has_no_stanzas(Carol),
<a name="519"/>  519:         true = is_sesssion_alive(Sid),
<a name="520"/>  520:         1 = wait_for_handler(CarolSessionPid)
<a name="521"/>  521: 
<a name="522"/>  522:         end).
<a name="523"/>  523: 
<a name="reply_on_pause-1"/><a name="524"/>  524: <b>reply_on_pause</b>(Config) -&gt;
<a name="525"/>  525:     escalus:story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="526"/>  526: 
<a name="527"/>  527: 
<a name="528"/>  528:         Sid = get_bosh_sid(Carol),
<a name="529"/>  529:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="530"/>  530:         set_keepalive(Carol, false),
<a name="531"/>  531: 
<a name="532"/>  532:         %% Sanity check - there should be one handler for Carol.
<a name="533"/>  533:         1 = wait_for_handler(CarolSessionPid),
<a name="534"/>  534: 
<a name="535"/>  535:         pause(Carol, 10),
<a name="536"/>  536: 
<a name="537"/>  537:         %% There should be no handlers for Carol,
<a name="538"/>  538:         %% but the session should be alive.
<a name="539"/>  539:         true = is_sesssion_alive(Sid),
<a name="540"/>  540:         0 = length(get_handlers(CarolSessionPid)),
<a name="541"/>  541:         0 = escalus_bosh:get_requests(Carol)
<a name="542"/>  542: 
<a name="543"/>  543:         end).
<a name="544"/>  544: 
<a name="cant_pause_for_too_long-1"/><a name="545"/>  545: <b>cant_pause_for_too_long</b>(Config) -&gt;
<a name="546"/>  546:     escalus:story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="547"/>  547: 
<a name="548"/>  548:         Sid = get_bosh_sid(Carol),
<a name="549"/>  549:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="550"/>  550:         set_keepalive(Carol, false),
<a name="551"/>  551: 
<a name="552"/>  552:         %% Sanity check - there should be one handler for Carol.
<a name="553"/>  553:         1 = wait_for_handler(CarolSessionPid),
<a name="554"/>  554: 
<a name="555"/>  555:         pause(Carol, 10000),
<a name="556"/>  556: 
<a name="557"/>  557:         escalus:assert(is_stream_end, escalus:wait_for_stanza(Carol)),
<a name="558"/>  558:         false = is_sesssion_alive(Sid)
<a name="559"/>  559: 
<a name="560"/>  560:         end).
<a name="561"/>  561: 
<a name="562"/>  562: <i>%% Ensure that a pause request causes inactivity timer cancellation.</i>
<a name="pause_request_is_activity-1"/><a name="563"/>  563: <b>pause_request_is_activity</b>(Config) -&gt;
<a name="564"/>  564:     escalus:story(Config, [{carol, 1}], fun(Carol) -&gt;
<a name="565"/>  565: 
<a name="566"/>  566:         Sid = get_bosh_sid(Carol),
<a name="567"/>  567:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="568"/>  568:         set_keepalive(Carol, false),
<a name="569"/>  569: 
<a name="570"/>  570:         %% Sanity check - there should be one handler for Carol.
<a name="571"/>  571:         1 = wait_for_handler(CarolSessionPid),
<a name="572"/>  572: 
<a name="573"/>  573:         %% Wait most of the allowed inactivity interval.
<a name="574"/>  574:         timer:sleep(timer:seconds(4)),
<a name="575"/>  575: 
<a name="576"/>  576:         %% This should cancel the inactivity timer.
<a name="577"/>  577:         pause(Carol, 10),
<a name="578"/>  578: 
<a name="579"/>  579:         %% Wait a bit past the inactivity interval.
<a name="580"/>  580:         timer:sleep(timer:seconds(4)),
<a name="581"/>  581: 
<a name="582"/>  582:         %% No disconnection should've occured.
<a name="583"/>  583:         escalus_assert:has_no_stanzas(Carol),
<a name="584"/>  584:         true = is_sesssion_alive(Sid)
<a name="585"/>  585: 
<a name="586"/>  586:         end).
<a name="587"/>  587: 
<a name="reply_in_time-1"/><a name="588"/>  588: <b>reply_in_time</b>(Config) -&gt;
<a name="589"/>  589:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="590"/>  590: 
<a name="591"/>  591:         Wait = proplists:get_value(bosh_wait,
<a name="592"/>  592:                                    escalus_users:get_userspec(Config, carol)),
<a name="593"/>  593: 
<a name="594"/>  594:         %% Don't send new long-polling requests waiting for server push.
<a name="595"/>  595:         set_keepalive(Carol, false),
<a name="596"/>  596: 
<a name="597"/>  597:         %% Make Carol receive using the last remaining connection.
<a name="598"/>  598:         escalus_client:send(Geralt,
<a name="599"/>  599:                             escalus_stanza:chat_to(Carol, &lt;&lt;&quot;Hello!&quot;&gt;&gt;)),
<a name="600"/>  600:         escalus:assert(is_chat_message, [&lt;&lt;&quot;Hello!&quot;&gt;&gt;],
<a name="601"/>  601:                        escalus_client:wait_for_stanza(Carol)),
<a name="602"/>  602: 
<a name="603"/>  603:         %% Sanity check - there should be no awaiting handlers.
<a name="604"/>  604:         {_, _, CarolSessionPid} = get_bosh_session(get_bosh_sid(Carol)),
<a name="605"/>  605:         0 = length(get_handlers(CarolSessionPid)),
<a name="606"/>  606: 
<a name="607"/>  607:         %% Send a single request and assert it's registered by server.
<a name="608"/>  608:         Rid = get_bosh_rid(Carol),
<a name="609"/>  609:         Sid = get_bosh_sid(Carol),
<a name="610"/>  610:         Empty = escalus_bosh:empty_body(Rid, Sid),
<a name="611"/>  611:         escalus_bosh:send_raw(Carol, Empty),
<a name="612"/>  612:         timer:sleep(100),
<a name="613"/>  613:         1 = wait_for_handler(CarolSessionPid),
<a name="614"/>  614: 
<a name="615"/>  615:         timer:sleep(timer:seconds(Wait) + 100),
<a name="616"/>  616: 
<a name="617"/>  617:         %% Assert the server has responded to that request.
<a name="618"/>  618:         0 = length(get_handlers(CarolSessionPid))
<a name="619"/>  619: 
<a name="620"/>  620:         end).
<a name="621"/>  621: 
<a name="server_acks-1"/><a name="622"/>  622: <b>server_acks</b>(Config) -&gt;
<a name="623"/>  623:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="624"/>  624: 
<a name="625"/>  625:         escalus_bosh:set_active(Carol, false),
<a name="626"/>  626:         ExpectedRid = list_to_binary(integer_to_list(get_bosh_rid(Carol))),
<a name="627"/>  627:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st!&quot;&gt;&gt;)),
<a name="628"/>  628:         escalus_client:send(Carol, escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd!&quot;&gt;&gt;)),
<a name="629"/>  629:         timer:sleep(200),
<a name="630"/>  630: 
<a name="631"/>  631:         All = recv_all(Carol),
<a name="632"/>  632:         ExpectedRid = exml_query:attr(hd(All), &lt;&lt;&quot;ack&quot;&gt;&gt;)
<a name="633"/>  633: 
<a name="634"/>  634:         end).
<a name="635"/>  635: 
<a name="force_report-1"/><a name="636"/>  636: <b>force_report</b>(Config) -&gt;
<a name="637"/>  637: 
<a name="638"/>  638:     %% Carol stores current Rid1
<a name="639"/>  639:     %% Carol sends msg1
<a name="640"/>  640:     %% Carol sends msg2
<a name="641"/>  641:     %% Geralt sends a reply to msg1
<a name="642"/>  642:     %% Geralt sends a reply to msg2
<a name="643"/>  643:     %% Carol recvs a reply to msg1
<a name="644"/>  644:     %% Carol recvs a reply to msg2
<a name="645"/>  645:     %% Carol sends an ack with Rid1 on empty BOSH wrapper
<a name="646"/>  646:     %% server sends a report
<a name="647"/>  647: 
<a name="648"/>  648:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="649"/>  649: 
<a name="650"/>  650:         StaleRid = get_bosh_rid(Carol),
<a name="651"/>  651:         escalus_client:send(Carol, chat_to(Geralt, &lt;&lt;&quot;1st msg&quot;&gt;&gt;)),
<a name="652"/>  652:         escalus_client:send(Carol, chat_to(Geralt, &lt;&lt;&quot;2nd msg&quot;&gt;&gt;)),
<a name="653"/>  653:         wait_for_stanzas(Geralt, 2),
<a name="654"/>  654:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep&quot;&gt;&gt;)),
<a name="655"/>  655:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;2nd rep&quot;&gt;&gt;)),
<a name="656"/>  656:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep&quot;&gt;&gt;],
<a name="657"/>  657:                        wait_for_stanza(Carol)),
<a name="658"/>  658:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd rep&quot;&gt;&gt;],
<a name="659"/>  659:                        wait_for_stanza(Carol)),
<a name="660"/>  660: 
<a name="661"/>  661:         %% Turn on client acknowledgement checking for Carol
<a name="662"/>  662:         {_, _, CarolSessionPid} = get_bosh_session(get_bosh_sid(Carol)),
<a name="663"/>  663:         set_client_acks(CarolSessionPid, true),
<a name="664"/>  664: 
<a name="665"/>  665:         escalus_bosh:set_active(Carol, false),
<a name="666"/>  666:         %% Send ack with StaleRid
<a name="667"/>  667:         Rid = get_bosh_rid(Carol),
<a name="668"/>  668:         Sid = get_bosh_sid(Carol),
<a name="669"/>  669:         BodyWithAck = ack_body(escalus_bosh:empty_body(Rid, Sid), StaleRid),
<a name="670"/>  670:         escalus_bosh:send_raw(Carol, BodyWithAck),
<a name="671"/>  671: 
<a name="672"/>  672:         %% Turn off client acknowledgement checking - don't cause server error
<a name="673"/>  673:         %% on subsequent requests without 'ack' attribute.
<a name="674"/>  674:         set_client_acks(CarolSessionPid, false),
<a name="675"/>  675: 
<a name="676"/>  676:         %% Expect a server report
<a name="677"/>  677:         timer:sleep(100),
<a name="678"/>  678:         MaybeReport = bosh_recv(Carol),
<a name="679"/>  679:         escalus:assert(is_bosh_report, [StaleRid+1], MaybeReport)
<a name="680"/>  680: 
<a name="681"/>  681:         end).
<a name="682"/>  682: 
<a name="force_retransmission-1"/><a name="683"/>  683: <b>force_retransmission</b>(Config) -&gt;
<a name="684"/>  684:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="685"/>  685: 
<a name="686"/>  686:         %% `send_raw` must be used as the exact request structure
<a name="687"/>  687:         %% is needed later for retransmission.
<a name="688"/>  688:         %% Hence, construct the request manually.
<a name="689"/>  689:         Rid = get_bosh_rid(Carol),
<a name="690"/>  690:         Sid = get_bosh_sid(Carol),
<a name="691"/>  691:         Empty = escalus_bosh:empty_body(Rid, Sid),
<a name="692"/>  692:         Chat = Empty#xmlel{
<a name="693"/>  693:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st msg!&quot;&gt;&gt;)]},
<a name="694"/>  694: 
<a name="695"/>  695:         %% Send msg, recv msg, send reply, recv reply.
<a name="696"/>  696:         %% This synchronous sequence sets up the server
<a name="697"/>  697:         %% to have the reply for Chat cached.
<a name="698"/>  698:         escalus_bosh:send_raw(Carol, Chat),
<a name="699"/>  699:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st msg!&quot;&gt;&gt;],
<a name="700"/>  700:                        wait_for_stanza(Geralt)),
<a name="701"/>  701:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep!&quot;&gt;&gt;)),
<a name="702"/>  702:         ChatResponse = wait_for_stanza(Carol),
<a name="703"/>  703:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep!&quot;&gt;&gt;], ChatResponse),
<a name="704"/>  704: 
<a name="705"/>  705:         %% Resend msg.
<a name="706"/>  706:         escalus_bosh:resend_raw(Carol, Chat),
<a name="707"/>  707: 
<a name="708"/>  708:         %% Recv same reply again.
<a name="709"/>  709:         ChatResponse = wait_for_stanza(Carol)
<a name="710"/>  710: 
<a name="711"/>  711:         end).
<a name="712"/>  712: 
<a name="force_cache_trimming-1"/><a name="713"/>  713: <b>force_cache_trimming</b>(Config) -&gt;
<a name="714"/>  714:     escalus:story(Config, [{carol, 1}, {geralt, 1}], fun(Carol, Geralt) -&gt;
<a name="715"/>  715: 
<a name="716"/>  716:         Sid = get_bosh_sid(Carol),
<a name="717"/>  717: 
<a name="718"/>  718:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="719"/>  719:         set_client_acks(CarolSessionPid, true),
<a name="720"/>  720: 
<a name="721"/>  721:         %% Ack now
<a name="722"/>  722:         Rid1 = get_bosh_rid(Carol),
<a name="723"/>  723:         Ack1 = ack_body(escalus_bosh:empty_body(Rid1, Sid), Rid1-1),
<a name="724"/>  724:         escalus_bosh:send_raw(Carol, Ack1),
<a name="725"/>  725: 
<a name="726"/>  726:         %% Exchange 2 messages
<a name="727"/>  727:         Rid2 = get_bosh_rid(Carol),
<a name="728"/>  728:         Chat = (escalus_bosh:empty_body(Rid2, Sid))#xmlel{
<a name="729"/>  729:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;1st msg!&quot;&gt;&gt;)]},
<a name="730"/>  730:         escalus_bosh:send_raw(Carol, Chat),
<a name="731"/>  731:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st msg!&quot;&gt;&gt;],
<a name="732"/>  732:                        wait_for_stanza(Geralt)),
<a name="733"/>  733:         escalus_client:send(Geralt, chat_to(Carol, &lt;&lt;&quot;1st rep!&quot;&gt;&gt;)),
<a name="734"/>  734:         ChatResponse = wait_for_stanza(Carol),
<a name="735"/>  735:         escalus:assert(is_chat_message, [&lt;&lt;&quot;1st rep!&quot;&gt;&gt;], ChatResponse),
<a name="736"/>  736: 
<a name="737"/>  737:         %% Ack/Chat again
<a name="738"/>  738:         Rid3 = get_bosh_rid(Carol),
<a name="739"/>  739:         AckedChat = (ack_body(escalus_bosh:empty_body(Rid3, Sid), Rid2))#xmlel{
<a name="740"/>  740:                 children = [escalus_stanza:chat_to(Geralt, &lt;&lt;&quot;2nd msg!&quot;&gt;&gt;)]},
<a name="741"/>  741:         escalus_bosh:send_raw(Carol, AckedChat),
<a name="742"/>  742:         escalus:assert(is_chat_message, [&lt;&lt;&quot;2nd msg!&quot;&gt;&gt;],
<a name="743"/>  743:                        wait_for_stanza(Geralt)),
<a name="744"/>  744: 
<a name="745"/>  745:         %% The cache should now contain only entries newer than Rid2.
<a name="746"/>  746:         {_, _, CarolSessionPid} = get_bosh_session(Sid),
<a name="747"/>  747:         Cache = get_cached_responses(CarolSessionPid),
<a name="748"/>  748:         true = lists:all(fun({R,_,_}) when R &gt; Rid2 -&gt; true; (_) -&gt; false end,
<a name="749"/>  749:                          Cache),
<a name="750"/>  750:         %% Not sure about this one...
<a name="751"/>  751:         1 = length(Cache),
<a name="752"/>  752: 
<a name="753"/>  753:         set_client_acks(CarolSessionPid, false)
<a name="754"/>  754: 
<a name="755"/>  755:         end).
<a name="756"/>  756: 
<a name="757"/>  757: <i>%%--------------------------------------------------------------------</i>
<a name="758"/>  758: <i>%% Helpers</i>
<a name="759"/>  759: <i>%%--------------------------------------------------------------------</i>
<a name="760"/>  760: 
<a name="get_bosh_sessions-0"/><a name="761"/>  761: <b>get_bosh_sessions</b>() -&gt;
<a name="762"/>  762:     Backend = escalus_ejabberd:rpc(mod_bosh_dynamic, backend, []),
<a name="763"/>  763:     escalus_ejabberd:rpc(Backend, get_sessions, []).
<a name="764"/>  764: 
<a name="get_bosh_session-1"/><a name="765"/>  765: <b>get_bosh_session</b>(Sid) -&gt;
<a name="766"/>  766:     BoshSessions = get_bosh_sessions(),
<a name="767"/>  767:     lists:keyfind(Sid, 2, BoshSessions).
<a name="768"/>  768: 
<a name="get_handlers-1"/><a name="769"/>  769: <b>get_handlers</b>(BoshSessionPid) -&gt;
<a name="770"/>  770:     escalus_ejabberd:rpc(mod_bosh_socket, get_handlers, [BoshSessionPid]).
<a name="771"/>  771: 
<a name="get_bosh_sid-1"/><a name="772"/>  772: <b>get_bosh_sid</b>(#client{} = Client) -&gt;
<a name="773"/>  773:     escalus_bosh:get_sid(Client).
<a name="774"/>  774: 
<a name="get_bosh_rid-1"/><a name="775"/>  775: <b>get_bosh_rid</b>(#client{} = C) -&gt;
<a name="776"/>  776:     escalus_bosh:get_rid(C).
<a name="777"/>  777: 
<a name="set_keepalive-2"/><a name="778"/>  778: <b>set_keepalive</b>(#client{} = C, Keepalive) -&gt;
<a name="779"/>  779:     escalus_bosh:set_keepalive(C, Keepalive).
<a name="780"/>  780: 
<a name="mark_as_terminated-1"/><a name="781"/>  781: <b>mark_as_terminated</b>(#client{} = C) -&gt;
<a name="782"/>  782:     escalus_bosh:mark_as_terminated(C).
<a name="783"/>  783: 
<a name="pause-2"/><a name="784"/>  784: <b>pause</b>(#client{} = C, Seconds) -&gt;
<a name="785"/>  785:     escalus_bosh:pause(C, Seconds),
<a name="786"/>  786:     timer:sleep(100).
<a name="787"/>  787: 
<a name="start_client-3"/><a name="788"/>  788: <b>start_client</b>(Config, User, Res) -&gt;
<a name="789"/>  789:     NamedSpecs = escalus_config:get_config(escalus_users, Config),
<a name="790"/>  790:     UserSpec = [{keepalive, false} | proplists:get_value(User, NamedSpecs)],
<a name="791"/>  791:     {ok, Client} = escalus_client:start(Config, UserSpec, Res),
<a name="792"/>  792:     Client.
<a name="793"/>  793: 
<a name="recv_all-1"/><a name="794"/>  794: <b>recv_all</b>(Client) -&gt;
<a name="795"/>  795:     recv_all(bosh_recv(Client), Client, []).
<a name="796"/>  796: 
<a name="recv_all-3"/><a name="797"/>  797: <b>recv_all</b>(empty, _Client, Acc) -&gt;
<a name="798"/>  798:     lists:reverse(Acc);
<a name="799"/>  799: <b>recv_all</b>(Element, Client, Acc) -&gt;
<a name="800"/>  800:     recv_all(bosh_recv(Client), Client, [Element | Acc]).
<a name="801"/>  801: 
<a name="bosh_recv-1"/><a name="802"/>  802: <b>bosh_recv</b>(#client{} = C) -&gt;
<a name="803"/>  803:     escalus_bosh:recv(C).
<a name="804"/>  804: 
<a name="chat_to-2"/><a name="805"/>  805: <b>chat_to</b>(Client, Content) -&gt;
<a name="806"/>  806:     escalus_stanza:chat_to(Client, Content).
<a name="807"/>  807: 
<a name="wait_for_stanzas-2"/><a name="808"/>  808: <b>wait_for_stanzas</b>(Client, Count) -&gt;
<a name="809"/>  809:     escalus_client:wait_for_stanzas(Client, Count).
<a name="810"/>  810: 
<a name="wait_for_stanza-1"/><a name="811"/>  811: <b>wait_for_stanza</b>(Client) -&gt;
<a name="812"/>  812:     escalus_client:wait_for_stanza(Client).
<a name="813"/>  813: 
<a name="wait_for_close-2"/><a name="814"/>  814: <b>wait_for_close</b>(Client, 0) -&gt;
<a name="815"/>  815:     false == escalus_connection:is_connected(Client);
<a name="816"/>  816: <b>wait_for_close</b>(Client, N) -&gt;
<a name="817"/>  817:     case escalus_connection:is_connected(Client) of
<a name="818"/>  818:         false -&gt;
<a name="819"/>  819:             true;
<a name="820"/>  820:         _ -&gt;
<a name="821"/>  821:             timer:sleep(100),
<a name="822"/>  822:             wait_for_close(Client, N-1)
<a name="823"/>  823:     end.
<a name="824"/>  824: 
<a name="ack_body-2"/><a name="825"/>  825: <b>ack_body</b>(Body, Rid) -&gt;
<a name="826"/>  826:     Attrs = Body#xmlel.attrs,
<a name="827"/>  827:     Ack = {&lt;&lt;&quot;ack&quot;&gt;&gt;, list_to_binary(integer_to_list(Rid))},
<a name="828"/>  828:     NewAttrs = lists:keystore(&lt;&lt;&quot;ack&quot;&gt;&gt;, 1, Attrs, Ack),
<a name="829"/>  829:     Body#xmlel{attrs = NewAttrs}.
<a name="830"/>  830: 
<a name="set_client_acks-2"/><a name="831"/>  831: <b>set_client_acks</b>(SessionPid, Enabled) -&gt;
<a name="832"/>  832:     escalus_ejabberd:rpc(mod_bosh_socket, set_client_acks,
<a name="833"/>  833:                          [SessionPid, Enabled]).
<a name="834"/>  834: 
<a name="get_cached_responses-1"/><a name="835"/>  835: <b>get_cached_responses</b>(SessionPid) -&gt;
<a name="836"/>  836:     escalus_ejabberd:rpc(mod_bosh_socket, get_cached_responses, [SessionPid]).
<a name="837"/>  837: 
<a name="inactivity-0"/><a name="838"/>  838: <b>inactivity</b>() -&gt;
<a name="839"/>  839:     inactivity(?INACTIVITY).
<a name="840"/>  840: 
<a name="inactivity-1"/><a name="841"/>  841: <b>inactivity</b>(Value) -&gt;
<a name="842"/>  842:     {inactivity,
<a name="843"/>  843:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_inactivity, []) end,
<a name="844"/>  844:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_inactivity, [V]) end,
<a name="845"/>  845:      Value}.
<a name="846"/>  846: 
<a name="max_wait-0"/><a name="847"/>  847: <b>max_wait</b>() -&gt;
<a name="848"/>  848:     max_wait(?MAX_WAIT).
<a name="849"/>  849: 
<a name="max_wait-1"/><a name="850"/>  850: <b>max_wait</b>(Value) -&gt;
<a name="851"/>  851:     {max_wait,
<a name="852"/>  852:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_max_wait, []) end,
<a name="853"/>  853:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_max_wait, [V]) end,
<a name="854"/>  854:      Value}.
<a name="855"/>  855: 
<a name="server_acks_opt-0"/><a name="856"/>  856: <b>server_acks_opt</b>() -&gt;
<a name="857"/>  857:     {server_acks,
<a name="858"/>  858:      fun() -&gt; escalus_ejabberd:rpc(mod_bosh, get_server_acks, []) end,
<a name="859"/>  859:      fun(V) -&gt; escalus_ejabberd:rpc(mod_bosh, set_server_acks, [V]) end,
<a name="860"/>  860:      true}.
<a name="861"/>  861: 
<a name="is_sesssion_alive-1"/><a name="862"/>  862: <b>is_sesssion_alive</b>(Sid) -&gt;
<a name="863"/>  863:     BoshSessions = get_bosh_sessions(),
<a name="864"/>  864:     lists:keymember(Sid, 2, BoshSessions).
<a name="865"/>  865: 
<a name="wait_for_session_close-2"/><a name="866"/>  866: <b>wait_for_session_close</b>(Sid, 0) -&gt;
<a name="867"/>  867:     false == is_sesssion_alive(Sid);
<a name="868"/>  868: <b>wait_for_session_close</b>(Sid, N) -&gt;
<a name="869"/>  869:     case is_sesssion_alive(Sid) of
<a name="870"/>  870:         false -&gt;
<a name="871"/>  871:             true;
<a name="872"/>  872:         _ -&gt;
<a name="873"/>  873:             timer:sleep(100),
<a name="874"/>  874:             wait_for_session_close(Sid, N-1)
<a name="875"/>  875:     end.
<a name="876"/>  876: 
<a name="wait_for_handler-1"/><a name="877"/>  877: <b>wait_for_handler</b>(Pid) -&gt;
<a name="878"/>  878:     wait_for_handler(Pid, 10).
<a name="879"/>  879: 
<a name="wait_for_handler-2"/><a name="880"/>  880: <b>wait_for_handler</b>(Pid, 0) -&gt;
<a name="881"/>  881:     length(get_handlers(Pid));
<a name="882"/>  882: <b>wait_for_handler</b>(Pid, N) -&gt;
<a name="883"/>  883:     case get_handlers(Pid) of
<a name="884"/>  884:         [] -&gt;
<a name="885"/>  885:             timer:sleep(50),
<a name="886"/>  886:             wait_for_handler(Pid, N-1);
<a name="887"/>  887:         L -&gt;
<a name="888"/>  888:             length(L)
<a name="889"/>  889:     end.
</pre>
</body>
</html>
